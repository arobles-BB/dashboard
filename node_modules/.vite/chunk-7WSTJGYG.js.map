{
  "version": 3,
  "sources": ["../.pnpm/@vaadin/vaadin-overlay@22.0.2/node_modules/@vaadin/vaadin-overlay/src/vaadin-focusables-helper.js", "../.pnpm/@vaadin/vaadin-overlay@22.0.2/node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * `Polymer.IronFocusablesHelper` relies on some Polymer-specific legacy API,\n * especially the `root` property which does not exist for native shadow DOM.\n * That's why we have this helper here.\n * See https://github.com/PolymerElements/iron-overlay-behavior/issues/282\n */\nclass FocusablesHelper {\n  /**\n   * Returns a sorted array of tabbable nodes, including the root node.\n   * It searches the tabbable nodes in the light and shadow dom of the children,\n   * sorting the result by tabindex.\n   * @param {!Node} node\n   * @return {!Array<!HTMLElement>}\n   */\n  static getTabbableNodes(node) {\n    const result = [];\n    // If there is at least one element with tabindex > 0, we need to sort\n    // the final array by tabindex.\n    const needsSortByTabIndex = this._collectTabbableNodes(node, result);\n    if (needsSortByTabIndex) {\n      return this._sortByTabIndex(result);\n    }\n    return result;\n  }\n\n  /**\n   * Returns if a element is focusable.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n  static isFocusable(element) {\n    // From http://stackoverflow.com/a/1600194/4228703:\n    // There isn't a definite list, it's up to the browser. The only\n    // standard we have is DOM Level 2 HTML\n    // https://www.w3.org/TR/DOM-Level-2-HTML/html.html, according to which the\n    // only elements that have a focus() method are HTMLInputElement,\n    // HTMLSelectElement, HTMLTextAreaElement and HTMLAnchorElement. This\n    // notably omits HTMLButtonElement and HTMLAreaElement. Referring to these\n    // tests with tabbables in different browsers\n    // http://allyjs.io/data-tables/focusable.html\n\n    // Elements that cannot be focused if they have [disabled] attribute.\n    if (element.matches('input, select, textarea, button, object')) {\n      return element.matches(':not([disabled])');\n    }\n    // Elements that can be focused even if they have [disabled] attribute.\n    return element.matches('a[href], area[href], iframe, [tabindex], [contentEditable]');\n  }\n\n  /**\n   * Returns if a element is tabbable. To be tabbable, a element must be\n   * focusable, visible, and with a tabindex !== -1.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n  static isTabbable(element) {\n    return this.isFocusable(element) && element.matches(':not([tabindex=\"-1\"])') && this._isVisible(element);\n  }\n\n  /**\n   * Returns the normalized element tabindex. If not focusable, returns -1.\n   * It checks for the attribute \"tabindex\" instead of the element property\n   * `tabIndex` since browsers assign different values to it.\n   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n   * @param {!HTMLElement} element\n   * @return {!number}\n   * @private\n   */\n  static _normalizedTabIndex(element) {\n    if (this.isFocusable(element)) {\n      const tabIndex = element.getAttribute('tabindex') || 0;\n      return Number(tabIndex);\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for nodes that are tabbable and adds them to the `result` array.\n   * Returns if the `result` array needs to be sorted by tabindex.\n   * @param {!Node} node The starting point for the search; added to `result` if tabbable.\n   * @param {!Array<!HTMLElement>} result\n   * @return {boolean}\n   * @private\n   */\n  static _collectTabbableNodes(node, result) {\n    // If not an element or not visible, no need to explore children.\n    if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {\n      return false;\n    }\n    const element = /** @type {!HTMLElement} */ (node);\n    const tabIndex = this._normalizedTabIndex(element);\n    let needsSort = tabIndex > 0;\n    if (tabIndex >= 0) {\n      result.push(element);\n    }\n\n    // In ShadowDOM v1, tab order is affected by the order of distribution.\n    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];\n    // in ShadowDOM v0 tab order is not affected by the distribution order,\n    // in fact getTabbableNodes(#root) returns [#B, #A].\n    //  <div id=\"root\">\n    //   <!-- shadow -->\n    //     <slot name=\"a\">\n    //     <slot name=\"b\">\n    //   <!-- /shadow -->\n    //   <input id=\"A\" slot=\"a\">\n    //   <input id=\"B\" slot=\"b\" tabindex=\"1\">\n    //  </div>\n    let children;\n    if (element.localName === 'slot') {\n      children = element.assignedNodes({ flatten: true });\n    } else {\n      // Use shadow root if possible, will check for distributed nodes.\n      children = (element.shadowRoot || element).children;\n    }\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        // Ensure method is always invoked to collect tabbable children.\n        needsSort = this._collectTabbableNodes(children[i], result) || needsSort;\n      }\n    }\n    return needsSort;\n  }\n\n  /**\n   * Returns false if the element has `visibility: hidden` or `display: none`\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   * @private\n   */\n  static _isVisible(element) {\n    // Check inline style first to save a re-flow. If looks good, check also\n    // computed style.\n    let style = element.style;\n    if (style.visibility !== 'hidden' && style.display !== 'none') {\n      style = window.getComputedStyle(element);\n      return style.visibility !== 'hidden' && style.display !== 'none';\n    }\n    return false;\n  }\n\n  /**\n   * Sorts an array of tabbable elements by tabindex. Returns a new array.\n   * @param {!Array<!HTMLElement>} tabbables\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n  static _sortByTabIndex(tabbables) {\n    // Implement a merge sort as Array.prototype.sort does a non-stable sort\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n    const len = tabbables.length;\n    if (len < 2) {\n      return tabbables;\n    }\n    const pivot = Math.ceil(len / 2);\n    const left = this._sortByTabIndex(tabbables.slice(0, pivot));\n    const right = this._sortByTabIndex(tabbables.slice(pivot));\n    return this._mergeSortByTabIndex(left, right);\n  }\n\n  /**\n   * Merge sort iterator, merges the two arrays into one, sorted by tab index.\n   * @param {!Array<!HTMLElement>} left\n   * @param {!Array<!HTMLElement>} right\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n  static _mergeSortByTabIndex(left, right) {\n    const result = [];\n    while (left.length > 0 && right.length > 0) {\n      if (this._hasLowerTabOrder(left[0], right[0])) {\n        result.push(right.shift());\n      } else {\n        result.push(left.shift());\n      }\n    }\n\n    return result.concat(left, right);\n  }\n\n  /**\n   * Returns if element `a` has lower tab order compared to element `b`\n   * (both elements are assumed to be focusable and tabbable).\n   * Elements with tabindex = 0 have lower tab order compared to elements\n   * with tabindex > 0.\n   * If both have same tabindex, it returns false.\n   * @param {!HTMLElement} a\n   * @param {!HTMLElement} b\n   * @return {boolean}\n   * @private\n   */\n  static _hasLowerTabOrder(a, b) {\n    // Normalize tabIndexes\n    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n    const ati = Math.max(a.tabIndex, 0);\n    const bti = Math.max(b.tabIndex, 0);\n    return ati === 0 || bti === 0 ? bti > ati : ati > bti;\n  }\n}\n\nexport { FocusablesHelper };\n", "/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';\nimport { templatize } from '@polymer/polymer/lib/utils/templatize.js';\nimport { html, PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { isIOS } from '@vaadin/component-base/src/browser-utils.js';\nimport { DirMixin } from '@vaadin/component-base/src/dir-mixin.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { FocusablesHelper } from './vaadin-focusables-helper.js';\n\n/**\n *\n * `<vaadin-overlay>` is a Web Component for creating overlays. The content of the overlay\n * can be populated in two ways: imperatively by using renderer callback function and\n * declaratively by using Polymer's Templates.\n *\n * ### Rendering\n *\n * By default, the overlay uses the content provided by using the renderer callback function.\n *\n * The renderer function provides `root`, `owner`, `model` arguments when applicable.\n * Generate DOM content by using `model` object properties if needed, append it to the `root`\n * element and control the state of the host element by accessing `owner`. Before generating new\n * content, users are able to check if there is already content in `root` for reusing it.\n *\n * ```html\n * <vaadin-overlay id=\"overlay\"></vaadin-overlay>\n * ```\n * ```js\n * const overlay = document.querySelector('#overlay');\n * overlay.renderer = function(root) {\n *  root.textContent = \"Overlay content\";\n * };\n * ```\n *\n * Renderer is called on the opening of the overlay and each time the related model is updated.\n * DOM generated during the renderer call can be reused\n * in the next renderer call and will be provided with the `root` argument.\n * On first call it will be empty.\n *\n * **NOTE:** when the renderer property is defined, the `<template>` content is not used.\n *\n * ### Templating\n *\n * Alternatively, the content can be provided with Polymer Template.\n * Overlay finds the first child template and uses that in case renderer callback function\n * is not provided. You can also set a custom template using the `template` property.\n *\n * After the content from the template is stamped, the `content` property\n * points to the content container.\n *\n * The overlay provides `forwardHostProp` when calling\n * `Polymer.Templatize.templatize` for the template, so that the bindings\n * from the parent scope propagate to the content.  You can also pass\n * custom `instanceProps` object using the `instanceProps` property.\n *\n * ```html\n * <vaadin-overlay>\n *   <template>Overlay content</template>\n * </vaadin-overlay>\n * ```\n *\n * **NOTE:** when using `instanceProps`: because of the Polymer limitation,\n * every template can only be templatized once, so it is important\n * to set `instanceProps` before the `template` is assigned to the overlay.\n *\n * ### Styling\n *\n * To style the overlay content, use styles in the parent scope:\n *\n * - If the overlay is used in a component, then the component styles\n *   apply the overlay content.\n * - If the overlay is used in the global DOM scope, then global styles\n *   apply to the overlay content.\n *\n * See examples for styling the overlay content in the live demos.\n *\n * The following Shadow DOM parts are available for styling the overlay component itself:\n *\n * Part name  | Description\n * -----------|---------------------------------------------------------|\n * `backdrop` | Backdrop of the overlay\n * `overlay`  | Container for position/sizing/alignment of the content\n * `content`  | Content of the overlay\n *\n * The following state attributes are available for styling:\n *\n * Attribute | Description | Part\n * ---|---|---\n * `opening` | Applied just after the overlay is attached to the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n * `closing` | Applied just before the overlay is detached from the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n *\n * The following custom CSS properties are available for styling:\n *\n * Custom CSS property | Description | Default value\n * ---|---|---\n * `--vaadin-overlay-viewport-bottom` | Bottom offset of the visible viewport area | `0` or detected offset\n *\n * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.\n *\n * @fires {CustomEvent} opened-changed - Fired when the `opened` property changes.\n *\n * @extends HTMLElement\n * @mixes ThemableMixin\n * @mixes DirMixin\n */\nclass OverlayElement extends ThemableMixin(DirMixin(PolymerElement)) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          z-index: 200;\n          position: fixed;\n\n          /* Despite of what the names say, <vaadin-overlay> is just a container\n          for position/sizing/alignment. The actual overlay is the overlay part. */\n\n          /* Default position constraints: the entire viewport. Note: themes can\n          override this to introduce gaps between the overlay and the viewport. */\n          top: 0;\n          right: 0;\n          bottom: var(--vaadin-overlay-viewport-bottom);\n          left: 0;\n\n          /* Use flexbox alignment for the overlay part. */\n          display: flex;\n          flex-direction: column; /* makes dropdowns sizing easier */\n          /* Align to center by default. */\n          align-items: center;\n          justify-content: center;\n\n          /* Allow centering when max-width/max-height applies. */\n          margin: auto;\n\n          /* The host is not clickable, only the overlay part is. */\n          pointer-events: none;\n\n          /* Remove tap highlight on touch devices. */\n          -webkit-tap-highlight-color: transparent;\n\n          /* CSS API for host */\n          --vaadin-overlay-viewport-bottom: 0;\n        }\n\n        :host([hidden]),\n        :host(:not([opened]):not([closing])) {\n          display: none !important;\n        }\n\n        [part='overlay'] {\n          -webkit-overflow-scrolling: touch;\n          overflow: auto;\n          pointer-events: auto;\n\n          /* Prevent overflowing the host in MSIE 11 */\n          max-width: 100%;\n          box-sizing: border-box;\n\n          -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */\n        }\n\n        [part='backdrop'] {\n          z-index: -1;\n          content: '';\n          background: rgba(0, 0, 0, 0.5);\n          position: fixed;\n          top: 0;\n          left: 0;\n          bottom: 0;\n          right: 0;\n          pointer-events: auto;\n        }\n      </style>\n\n      <div id=\"backdrop\" part=\"backdrop\" hidden$=\"[[!withBackdrop]]\"></div>\n      <div part=\"overlay\" id=\"overlay\" tabindex=\"0\">\n        <div part=\"content\" id=\"content\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-overlay';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * When true, the overlay is visible and attached to body.\n       */\n      opened: {\n        type: Boolean,\n        notify: true,\n        observer: '_openedChanged',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Owner element passed with renderer function\n       * @type {HTMLElement}\n       */\n      owner: Element,\n\n      /**\n       * Custom function for rendering the content of the overlay.\n       * Receives three arguments:\n       *\n       * - `root` The root container DOM element. Append your content to it.\n       * - `owner` The host element of the renderer function.\n       * - `model` The object with the properties related with rendering.\n       * @type {OverlayRenderer | null | undefined}\n       */\n      renderer: Function,\n\n      /**\n       * The template of the overlay content.\n       * @type {HTMLTemplateElement | null | undefined}\n       */\n      template: {\n        type: Object,\n        notify: true\n      },\n\n      /**\n       * Optional argument for `Polymer.Templatize.templatize`.\n       */\n      instanceProps: {\n        type: Object\n      },\n\n      /**\n       * References the content container after the template is stamped.\n       * @type {!HTMLElement | undefined}\n       */\n      content: {\n        type: Object,\n        notify: true\n      },\n\n      /**\n       * When true the overlay has backdrop on top of content when opened.\n       * @type {boolean}\n       */\n      withBackdrop: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Object with properties that is passed to `renderer` function\n       */\n      model: Object,\n\n      /**\n       * When true the overlay won't disable the main content, showing\n       * it doesn\u2019t change the functionality of the user interface.\n       * @type {boolean}\n       */\n      modeless: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_modelessChanged'\n      },\n\n      /**\n       * When set to true, the overlay is hidden. This also closes the overlay\n       * immediately in case there is a closing animation in progress.\n       * @type {boolean}\n       */\n      hidden: {\n        type: Boolean,\n        reflectToAttribute: true,\n        observer: '_hiddenChanged'\n      },\n\n      /**\n       * When true move focus to the first focusable element in the overlay,\n       * or to the overlay if there are no focusable elements.\n       * @type {boolean}\n       */\n      focusTrap: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Set to true to enable restoring of focus when overlay is closed.\n       * @type {boolean}\n       */\n      restoreFocusOnClose: {\n        type: Boolean,\n        value: false\n      },\n\n      /** @private */\n      _mouseDownInside: {\n        type: Boolean\n      },\n\n      /** @private */\n      _mouseUpInside: {\n        type: Boolean\n      },\n\n      /** @private */\n      _instance: {\n        type: Object\n      },\n\n      /** @private */\n      _originalContentPart: Object,\n\n      /** @private */\n      _contentNodes: Array,\n\n      /** @private */\n      _oldOwner: Element,\n\n      /** @private */\n      _oldModel: Object,\n\n      /** @private */\n      _oldTemplate: Object,\n\n      /** @private */\n      _oldInstanceProps: Object,\n\n      /** @private */\n      _oldRenderer: Object,\n\n      /** @private */\n      _oldOpened: Boolean\n    };\n  }\n\n  static get observers() {\n    return ['_templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened)'];\n  }\n\n  constructor() {\n    super();\n    this._boundMouseDownListener = this._mouseDownListener.bind(this);\n    this._boundMouseUpListener = this._mouseUpListener.bind(this);\n    this._boundOutsideClickListener = this._outsideClickListener.bind(this);\n    this._boundKeydownListener = this._keydownListener.bind(this);\n\n    this._observer = new FlattenedNodesObserver(this, (info) => {\n      this._setTemplateFromNodes(info.addedNodes);\n    });\n\n    // Listener for preventing closing of the paper-dialog and all components extending `iron-overlay-behavior`.\n    this._boundIronOverlayCanceledListener = this._ironOverlayCanceled.bind(this);\n\n    /* c8 ignore next 3 */\n    if (isIOS) {\n      this._boundIosResizeListener = () => this._detectIosNavbar();\n    }\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n\n    this._observer.flush();\n\n    // Need to add dummy click listeners to this and the backdrop or else\n    // the document click event listener (_outsideClickListener) may never\n    // get invoked on iOS Safari (reproducible in <vaadin-dialog>\n    // and <vaadin-context-menu>).\n    this.addEventListener('click', () => {});\n    this.$.backdrop.addEventListener('click', () => {});\n  }\n\n  /** @private */\n  _detectIosNavbar() {\n    /* c8 ignore next 15 */\n    if (!this.opened) {\n      return;\n    }\n\n    const innerHeight = window.innerHeight;\n    const innerWidth = window.innerWidth;\n\n    const landscape = innerWidth > innerHeight;\n\n    const clientHeight = document.documentElement.clientHeight;\n\n    if (landscape && clientHeight > innerHeight) {\n      this.style.setProperty('--vaadin-overlay-viewport-bottom', clientHeight - innerHeight + 'px');\n    } else {\n      this.style.setProperty('--vaadin-overlay-viewport-bottom', '0');\n    }\n  }\n\n  /**\n   * @param {!Array<!Element>} nodes\n   * @protected\n   */\n  _setTemplateFromNodes(nodes) {\n    this.template = nodes.filter((node) => node.localName && node.localName === 'template')[0] || this.template;\n  }\n\n  /**\n   * @param {Event=} sourceEvent\n   * @event vaadin-overlay-close\n   * fired before the `vaadin-overlay` will be closed. If canceled the closing of the overlay is canceled as well.\n   */\n  close(sourceEvent) {\n    var evt = new CustomEvent('vaadin-overlay-close', {\n      bubbles: true,\n      cancelable: true,\n      detail: { sourceEvent: sourceEvent }\n    });\n    this.dispatchEvent(evt);\n    if (!evt.defaultPrevented) {\n      this.opened = false;\n    }\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n\n    /* c8 ignore next 3 */\n    if (this._boundIosResizeListener) {\n      this._detectIosNavbar();\n      window.addEventListener('resize', this._boundIosResizeListener);\n    }\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    /* c8 ignore next 3 */\n    if (this._boundIosResizeListener) {\n      window.removeEventListener('resize', this._boundIosResizeListener);\n    }\n  }\n\n  /**\n   * Requests an update for the content of the overlay.\n   * While performing the update, it invokes the renderer passed in the `renderer` property.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n  requestContentUpdate() {\n    if (this.renderer) {\n      this.renderer.call(this.owner, this.content, this.owner, this.model);\n    }\n  }\n\n  /** @private */\n  _ironOverlayCanceled(event) {\n    event.preventDefault();\n  }\n\n  /** @private */\n  _mouseDownListener(event) {\n    this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n  }\n\n  /** @private */\n  _mouseUpListener(event) {\n    this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n  }\n\n  /**\n   * We need to listen on 'click' / 'tap' event and capture it and close the overlay before\n   * propagating the event to the listener in the button. Otherwise, if the clicked button would call\n   * open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4\n   *\n   * @event vaadin-overlay-outside-click\n   * fired before the `vaadin-overlay` will be closed on outside click. If canceled the closing of the overlay is canceled as well.\n   *\n   * @private\n   */\n  _outsideClickListener(event) {\n    if (event.composedPath().indexOf(this.$.overlay) !== -1 || this._mouseDownInside || this._mouseUpInside) {\n      this._mouseDownInside = false;\n      this._mouseUpInside = false;\n      return;\n    }\n    if (!this._last) {\n      return;\n    }\n\n    const evt = new CustomEvent('vaadin-overlay-outside-click', {\n      bubbles: true,\n      cancelable: true,\n      detail: { sourceEvent: event }\n    });\n    this.dispatchEvent(evt);\n\n    if (this.opened && !evt.defaultPrevented) {\n      this.close(event);\n    }\n  }\n\n  /**\n   * @event vaadin-overlay-escape-press\n   * fired before the `vaadin-overlay` will be closed on ESC button press. If canceled the closing of the overlay is canceled as well.\n   *\n   * @private\n   */\n  _keydownListener(event) {\n    if (!this._last) {\n      return;\n    }\n\n    // TAB\n    if (event.key === 'Tab' && this.focusTrap && !event.defaultPrevented) {\n      // if only tab key is pressed, cycle forward, else cycle backwards.\n      this._cycleTab(event.shiftKey ? -1 : 1);\n\n      event.preventDefault();\n\n      // ESC\n    } else if (event.key === 'Escape' || event.key === 'Esc') {\n      const evt = new CustomEvent('vaadin-overlay-escape-press', {\n        bubbles: true,\n        cancelable: true,\n        detail: { sourceEvent: event }\n      });\n      this.dispatchEvent(evt);\n\n      if (this.opened && !evt.defaultPrevented) {\n        this.close(event);\n      }\n    }\n  }\n\n  /** @protected */\n  _ensureTemplatized() {\n    this._setTemplateFromNodes(Array.from(this.children));\n  }\n\n  /**\n   * @event vaadin-overlay-open\n   * fired after the `vaadin-overlay` is opened.\n   *\n   * @private\n   */\n  _openedChanged(opened, wasOpened) {\n    if (!this._instance) {\n      this._ensureTemplatized();\n    }\n\n    if (opened) {\n      // Store focused node.\n      this.__restoreFocusNode = this._getActiveElement();\n      this._animatedOpening();\n\n      afterNextRender(this, () => {\n        if (this.focusTrap && !this.contains(document.activeElement)) {\n          this._cycleTab(0, 0);\n        }\n\n        const evt = new CustomEvent('vaadin-overlay-open', { bubbles: true });\n        this.dispatchEvent(evt);\n      });\n\n      if (!this.modeless) {\n        this._addGlobalListeners();\n      }\n    } else if (wasOpened) {\n      this._animatedClosing();\n\n      if (!this.modeless) {\n        this._removeGlobalListeners();\n      }\n    }\n  }\n\n  /** @private */\n  _hiddenChanged(hidden) {\n    if (hidden && this.hasAttribute('closing')) {\n      this._flushAnimation('closing');\n    }\n  }\n\n  /**\n   * @return {boolean}\n   * @protected\n   */\n  _shouldAnimate() {\n    const name = getComputedStyle(this).getPropertyValue('animation-name');\n    const hidden = getComputedStyle(this).getPropertyValue('display') === 'none';\n    return !hidden && name && name != 'none';\n  }\n\n  /**\n   * @param {string} type\n   * @param {Function} callback\n   * @protected\n   */\n  _enqueueAnimation(type, callback) {\n    const handler = `__${type}Handler`;\n    const listener = (event) => {\n      if (event && event.target !== this) {\n        return;\n      }\n      callback();\n      this.removeEventListener('animationend', listener);\n      delete this[handler];\n    };\n    this[handler] = listener;\n    this.addEventListener('animationend', listener);\n  }\n\n  /**\n   * @param {string} type\n   * @protected\n   */\n  _flushAnimation(type) {\n    const handler = `__${type}Handler`;\n    if (typeof this[handler] === 'function') {\n      this[handler]();\n    }\n  }\n\n  /** @protected */\n  _animatedOpening() {\n    if (this.parentNode === document.body && this.hasAttribute('closing')) {\n      this._flushAnimation('closing');\n    }\n    this._attachOverlay();\n    if (!this.modeless) {\n      this._enterModalState();\n    }\n    this.setAttribute('opening', '');\n\n    const finishOpening = () => {\n      document.addEventListener('iron-overlay-canceled', this._boundIronOverlayCanceledListener);\n\n      this.removeAttribute('opening');\n    };\n\n    if (this._shouldAnimate()) {\n      this._enqueueAnimation('opening', finishOpening);\n    } else {\n      finishOpening();\n    }\n  }\n\n  /** @protected */\n  _attachOverlay() {\n    this._placeholder = document.createComment('vaadin-overlay-placeholder');\n    this.parentNode.insertBefore(this._placeholder, this);\n    document.body.appendChild(this);\n    this.bringToFront();\n  }\n\n  /** @protected */\n  _animatedClosing() {\n    if (this.hasAttribute('opening')) {\n      this._flushAnimation('opening');\n    }\n    if (this._placeholder) {\n      this._exitModalState();\n\n      if (this.restoreFocusOnClose && this.__restoreFocusNode) {\n        // If the activeElement is `<body>` or inside the overlay,\n        // we are allowed to restore the focus. In all the other\n        // cases focus might have been moved elsewhere by another\n        // component or by the user interaction (e.g. click on a\n        // button outside the overlay).\n        const activeElement = this._getActiveElement();\n\n        if (activeElement === document.body || this._deepContains(activeElement)) {\n          this.__restoreFocusNode.focus();\n        }\n        this.__restoreFocusNode = null;\n      }\n\n      this.setAttribute('closing', '');\n\n      const finishClosing = () => {\n        document.removeEventListener('iron-overlay-canceled', this._boundIronOverlayCanceledListener);\n        this._detachOverlay();\n        this.shadowRoot.querySelector('[part=\"overlay\"]').style.removeProperty('pointer-events');\n        this.removeAttribute('closing');\n      };\n\n      if (this._shouldAnimate()) {\n        this._enqueueAnimation('closing', finishClosing);\n      } else {\n        finishClosing();\n      }\n    }\n  }\n\n  /** @protected */\n  _detachOverlay() {\n    this._placeholder.parentNode.insertBefore(this, this._placeholder);\n    this._placeholder.parentNode.removeChild(this._placeholder);\n  }\n\n  /**\n   * Returns all attached overlays in visual stacking order.\n   * @private\n   */\n  static get __attachedInstances() {\n    return Array.from(document.body.children)\n      .filter((el) => el instanceof OverlayElement && !el.hasAttribute('closing'))\n      .sort((a, b) => a.__zIndex - b.__zIndex || 0);\n  }\n\n  /**\n   * returns true if this is the last one in the opened overlays stack\n   * @return {boolean}\n   * @protected\n   */\n  get _last() {\n    return this === OverlayElement.__attachedInstances.pop();\n  }\n\n  /** @private */\n  _modelessChanged(modeless) {\n    if (!modeless) {\n      if (this.opened) {\n        this._addGlobalListeners();\n        this._enterModalState();\n      }\n    } else {\n      this._removeGlobalListeners();\n      this._exitModalState();\n    }\n  }\n\n  /** @protected */\n  _addGlobalListeners() {\n    document.addEventListener('mousedown', this._boundMouseDownListener);\n    document.addEventListener('mouseup', this._boundMouseUpListener);\n    // Firefox leaks click to document on contextmenu even if prevented\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=990614\n    document.documentElement.addEventListener('click', this._boundOutsideClickListener, true);\n    document.addEventListener('keydown', this._boundKeydownListener);\n  }\n\n  /** @protected */\n  _enterModalState() {\n    if (document.body.style.pointerEvents !== 'none') {\n      // Set body pointer-events to 'none' to disable mouse interactions with\n      // other document nodes.\n      this._previousDocumentPointerEvents = document.body.style.pointerEvents;\n      document.body.style.pointerEvents = 'none';\n    }\n\n    // Disable pointer events in other attached overlays\n    OverlayElement.__attachedInstances.forEach((el) => {\n      if (el !== this) {\n        el.shadowRoot.querySelector('[part=\"overlay\"]').style.pointerEvents = 'none';\n      }\n    });\n  }\n\n  /** @protected */\n  _removeGlobalListeners() {\n    document.removeEventListener('mousedown', this._boundMouseDownListener);\n    document.removeEventListener('mouseup', this._boundMouseUpListener);\n    document.documentElement.removeEventListener('click', this._boundOutsideClickListener, true);\n    document.removeEventListener('keydown', this._boundKeydownListener);\n  }\n\n  /** @protected */\n  _exitModalState() {\n    if (this._previousDocumentPointerEvents !== undefined) {\n      // Restore body pointer-events\n      document.body.style.pointerEvents = this._previousDocumentPointerEvents;\n      delete this._previousDocumentPointerEvents;\n    }\n\n    // Restore pointer events in the previous overlay(s)\n    const instances = OverlayElement.__attachedInstances;\n    let el;\n    // Use instances.pop() to ensure the reverse order\n    while ((el = instances.pop())) {\n      if (el === this) {\n        // Skip the current instance\n        continue;\n      }\n      el.shadowRoot.querySelector('[part=\"overlay\"]').style.removeProperty('pointer-events');\n      if (!el.modeless) {\n        // Stop after the last modal\n        break;\n      }\n    }\n  }\n\n  /** @protected */\n  _removeOldContent() {\n    if (!this.content || !this._contentNodes) {\n      return;\n    }\n\n    this._observer.disconnect();\n\n    this._contentNodes.forEach((node) => {\n      if (node.parentNode === this.content) {\n        this.content.removeChild(node);\n      }\n    });\n\n    if (this._originalContentPart) {\n      // Restore the original <div part=\"content\">\n      this.$.content.parentNode.replaceChild(this._originalContentPart, this.$.content);\n      this.$.content = this._originalContentPart;\n      this._originalContentPart = undefined;\n    }\n\n    this._observer.connect();\n\n    this._contentNodes = undefined;\n    this.content = undefined;\n  }\n\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {object} instanceProps\n   * @protected\n   */\n  _stampOverlayTemplate(template, instanceProps) {\n    this._removeOldContent();\n\n    if (!template._Templatizer) {\n      template._Templatizer = templatize(template, this, {\n        instanceProps: instanceProps,\n        forwardHostProp: function (prop, value) {\n          if (this._instance) {\n            this._instance.forwardHostProp(prop, value);\n          }\n        }\n      });\n    }\n\n    this._instance = new template._Templatizer({});\n    this._contentNodes = Array.from(this._instance.root.childNodes);\n\n    const templateRoot = template._templateRoot || (template._templateRoot = template.getRootNode());\n\n    if (templateRoot !== document) {\n      if (!this.$.content.shadowRoot) {\n        this.$.content.attachShadow({ mode: 'open' });\n      }\n\n      let scopeCssText = Array.from(templateRoot.querySelectorAll('style')).reduce(\n        (result, style) => result + style.textContent,\n        ''\n      );\n\n      // The overlay root\u2019s :host styles should not apply inside the overlay\n      scopeCssText = scopeCssText.replace(/:host/g, ':host-nomatch');\n\n      if (scopeCssText) {\n        // Append a style to the content shadowRoot\n        const style = document.createElement('style');\n        style.textContent = scopeCssText;\n        this.$.content.shadowRoot.appendChild(style);\n        this._contentNodes.unshift(style);\n      }\n\n      this.$.content.shadowRoot.appendChild(this._instance.root);\n      this.content = this.$.content.shadowRoot;\n    } else {\n      this.appendChild(this._instance.root);\n      this.content = this;\n    }\n  }\n\n  /** @private */\n  _removeNewRendererOrTemplate(template, oldTemplate, renderer, oldRenderer) {\n    if (template !== oldTemplate) {\n      this.template = undefined;\n    } else if (renderer !== oldRenderer) {\n      this.renderer = undefined;\n    }\n  }\n\n  /** @private */\n  _templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened) {\n    if (template && renderer) {\n      this._removeNewRendererOrTemplate(template, this._oldTemplate, renderer, this._oldRenderer);\n      throw new Error('You should only use either a renderer or a template for overlay content');\n    }\n\n    const ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;\n    this._oldModel = model;\n    this._oldOwner = owner;\n\n    const templateOrInstancePropsChanged = this._oldInstanceProps !== instanceProps || this._oldTemplate !== template;\n    this._oldInstanceProps = instanceProps;\n    this._oldTemplate = template;\n\n    const rendererChanged = this._oldRenderer !== renderer;\n    this._oldRenderer = renderer;\n\n    const openedChanged = this._oldOpened !== opened;\n    this._oldOpened = opened;\n\n    if (rendererChanged) {\n      this.content = this;\n      this.content.innerHTML = '';\n      // Whenever a Lit-based renderer is used, it assigns a Lit part to the node it was rendered into.\n      // When clearing the rendered content, this part needs to be manually disposed of.\n      // Otherwise, using a Lit-based renderer on the same node will throw an exception or render nothing afterward.\n      delete this.content._$litPart$;\n    }\n\n    if (template && templateOrInstancePropsChanged) {\n      this._stampOverlayTemplate(template, instanceProps);\n    } else if (renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {\n      if (opened) {\n        this.requestContentUpdate();\n      }\n    }\n  }\n\n  /**\n   * @param {Element} element\n   * @return {boolean}\n   * @protected\n   */\n  _isFocused(element) {\n    return element && element.getRootNode().activeElement === element;\n  }\n\n  /**\n   * @param {Element[]} elements\n   * @return {number}\n   * @protected\n   */\n  _focusedIndex(elements) {\n    elements = elements || this._getFocusableElements();\n    return elements.indexOf(elements.filter(this._isFocused).pop());\n  }\n\n  /**\n   * @param {number} increment\n   * @param {number | undefined} index\n   * @protected\n   */\n  _cycleTab(increment, index) {\n    const focusableElements = this._getFocusableElements();\n\n    if (index === undefined) {\n      index = this._focusedIndex(focusableElements);\n    }\n\n    index += increment;\n\n    // rollover to first item\n    if (index >= focusableElements.length) {\n      index = 0;\n      // go to last item\n    } else if (index < 0) {\n      index = focusableElements.length - 1;\n    }\n\n    focusableElements[index].focus();\n  }\n\n  /**\n   * @return {!Array<!HTMLElement>}\n   * @protected\n   */\n  _getFocusableElements() {\n    // collect all focusable elements\n    return FocusablesHelper.getTabbableNodes(this.$.overlay);\n  }\n\n  /**\n   * @return {!Element}\n   * @protected\n   */\n  _getActiveElement() {\n    // document.activeElement can be null\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement\n    let active = document.activeElement || document.body;\n    while (active.shadowRoot && active.shadowRoot.activeElement) {\n      active = active.shadowRoot.activeElement;\n    }\n    return active;\n  }\n\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   * @protected\n   */\n  _deepContains(node) {\n    if (this.contains(node)) {\n      return true;\n    }\n    let n = node;\n    const doc = node.ownerDocument;\n    // walk from node to `this` or `document`\n    while (n && n !== doc && n !== this) {\n      n = n.parentNode || n.host;\n    }\n    return n === this;\n  }\n\n  /**\n   * Brings the overlay as visually the frontmost one\n   */\n  bringToFront() {\n    let zIndex = '';\n    const frontmost = OverlayElement.__attachedInstances.filter((o) => o !== this).pop();\n    if (frontmost) {\n      const frontmostZIndex = frontmost.__zIndex;\n      zIndex = frontmostZIndex + 1;\n    }\n    this.style.zIndex = zIndex;\n    this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);\n  }\n}\n\ncustomElements.define(OverlayElement.is, OverlayElement);\nexport { OverlayElement };\n"],
  "mappings": "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",
  "names": []
}
