{
  "version": 3,
  "sources": ["../.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/utils/gestures.js"],
  "sourcesContent": ["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * Module for adding listeners to a node for the following normalized\n * cross-platform \"gesture\" events:\n * - `down` - mouse or touch went down\n * - `up` - mouse or touch went up\n * - `tap` - mouse click or finger tap\n * - `track` - mouse drag or touch move\n *\n * @summary Module for adding cross-platform gesture event listeners.\n */\n\nimport './boot.js';\n\nimport { timeOut, microTask } from './async.js';\nimport { Debouncer } from './debounce.js';\nimport { passiveTouchGestures } from './settings.js';\nimport { wrap } from './wrap.js';\n\n// detect native touch action support\nlet HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nlet GESTURE_KEY = '__polymerGestures';\nlet HANDLED_OBJ = '__polymerGesturesHandled';\nlet TOUCH_ACTION = '__polymerGesturesTouchAction';\n// radius for tap and track\nlet TAP_DISTANCE = 25;\nlet TRACK_DISTANCE = 5;\n// number of last N track positions to keep\nlet TRACK_LENGTH = 2;\n\n// Disabling \"mouse\" handlers for 2500ms is enough\nlet MOUSE_TIMEOUT = 2500;\nlet MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];\n// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\nlet MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\nlet MOUSE_HAS_BUTTONS = (function() {\n  try {\n    return new MouseEvent('test', {buttons: 1}).buttons === 1;\n  } catch (e) {\n    return false;\n  }\n})();\n\n/**\n * @param {string} name Possible mouse event name\n * @return {boolean} true if mouse event, false if not\n */\nfunction isMouseEvent(name) {\n  return MOUSE_EVENTS.indexOf(name) > -1;\n}\n\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n// check for passive event listeners\nlet SUPPORTS_PASSIVE = false;\n(function() {\n  try {\n    let opts = Object.defineProperty({}, 'passive', {get() {SUPPORTS_PASSIVE = true;}});\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch(e) {}\n})();\n\n/**\n * Generate settings for event listeners, dependant on `passiveTouchGestures`\n *\n * @param {string} eventName Event name to determine if `{passive}` option is\n *   needed\n * @return {{passive: boolean} | undefined} Options to use for addEventListener\n *   and removeEventListener\n */\nfunction PASSIVE_TOUCH(eventName) {\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\n    return;\n  }\n  if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && passiveTouchGestures) {\n    return {passive: true};\n  } else {\n    return;\n  }\n}\n\n// Check for touch-only devices\nlet IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);\n\n// keep track of any labels hit by the mouseCanceller\n/** @type {!Array<!HTMLLabelElement>} */\nconst clickedLabels = [];\n\n/** @type {!Object<boolean>} */\nconst labellable = {\n  'button': true,\n  'input': true,\n  'keygen': true,\n  'meter': true,\n  'output': true,\n  'textarea': true,\n  'progress': true,\n  'select': true\n};\n\n// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute\n/** @type {!Object<boolean>} */\nconst canBeDisabled = {\n  'button': true,\n  'command': true,\n  'fieldset': true,\n  'input': true,\n  'keygen': true,\n  'optgroup': true,\n  'option': true,\n  'select': true,\n  'textarea': true\n};\n\n/**\n * @param {HTMLElement} el Element to check labelling status\n * @return {boolean} element can have labels\n */\nfunction canBeLabelled(el) {\n  return labellable[el.localName] || false;\n}\n\n/**\n * @param {HTMLElement} el Element that may be labelled.\n * @return {!Array<!HTMLLabelElement>} Relevant label for `el`\n */\nfunction matchingLabels(el) {\n  let labels = Array.prototype.slice.call(/** @type {HTMLInputElement} */(el).labels || []);\n  // IE doesn't have `labels` and Safari doesn't populate `labels`\n  // if element is in a shadowroot.\n  // In this instance, finding the non-ancestor labels is enough,\n  // as the mouseCancellor code will handle ancstor labels\n  if (!labels.length) {\n    labels = [];\n    let root = el.getRootNode();\n    // if there is an id on `el`, check for all labels with a matching `for` attribute\n    if (el.id) {\n      let matching = root.querySelectorAll(`label[for = ${el.id}]`);\n      for (let i = 0; i < matching.length; i++) {\n        labels.push(/** @type {!HTMLLabelElement} */(matching[i]));\n      }\n    }\n  }\n  return labels;\n}\n\n// touch will make synthetic mouse events\n// `preventDefault` on touchend will cancel them,\n// but this breaks `<input>` focus and link clicks\n// disable mouse handlers for MOUSE_TIMEOUT ms after\n// a touchend to ignore synthetic mouse events\nlet mouseCanceller = function(mouseEvent) {\n  // Check for sourceCapabilities, used to distinguish synthetic events\n  // if mouseEvent did not come from a device that fires touch events,\n  // it was made by a real mouse and should be counted\n  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents\n  let sc = mouseEvent.sourceCapabilities;\n  if (sc && !sc.firesTouchEvents) {\n    return;\n  }\n  // skip synthetic mouse events\n  mouseEvent[HANDLED_OBJ] = {skip: true};\n  // disable \"ghost clicks\"\n  if (mouseEvent.type === 'click') {\n    let clickFromLabel = false;\n    let path = getComposedPath(mouseEvent);\n    for (let i = 0; i < path.length; i++) {\n      if (path[i].nodeType === Node.ELEMENT_NODE) {\n        if (path[i].localName === 'label') {\n          clickedLabels.push(/** @type {!HTMLLabelElement} */ (path[i]));\n        } else if (canBeLabelled(/** @type {!HTMLElement} */ (path[i]))) {\n          let ownerLabels =\n              matchingLabels(/** @type {!HTMLElement} */ (path[i]));\n          // check if one of the clicked labels is labelling this element\n          for (let j = 0; j < ownerLabels.length; j++) {\n            clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;\n          }\n        }\n      }\n      if (path[i] === POINTERSTATE.mouse.target) {\n        return;\n      }\n    }\n    // if one of the clicked labels was labelling the target element,\n    // this is not a ghost click\n    if (clickFromLabel) {\n      return;\n    }\n    mouseEvent.preventDefault();\n    mouseEvent.stopPropagation();\n  }\n};\n\n/**\n * @param {boolean=} setup True to add, false to remove.\n * @return {void}\n */\nfunction setupTeardownMouseCanceller(setup) {\n  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;\n  for (let i = 0, en; i < events.length; i++) {\n    en = events[i];\n    if (setup) {\n      // reset clickLabels array\n      clickedLabels.length = 0;\n      document.addEventListener(en, mouseCanceller, true);\n    } else {\n      document.removeEventListener(en, mouseCanceller, true);\n    }\n  }\n}\n\nfunction ignoreMouse(e) {\n  if (!POINTERSTATE.mouse.mouseIgnoreJob) {\n    setupTeardownMouseCanceller(true);\n  }\n  let unset = function() {\n    setupTeardownMouseCanceller();\n    POINTERSTATE.mouse.target = null;\n    POINTERSTATE.mouse.mouseIgnoreJob = null;\n  };\n  POINTERSTATE.mouse.target = getComposedPath(e)[0];\n  POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(\n        POINTERSTATE.mouse.mouseIgnoreJob\n      , timeOut.after(MOUSE_TIMEOUT)\n      , unset);\n}\n\n/**\n * @param {MouseEvent} ev event to test for left mouse button down\n * @return {boolean} has left mouse button down\n */\nfunction hasLeftMouseButton(ev) {\n  let type = ev.type;\n  // exit early if the event is not a mouse event\n  if (!isMouseEvent(type)) {\n    return false;\n  }\n  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\n  if (type === 'mousemove') {\n    // allow undefined for testing events\n    let buttons = ev.buttons === undefined ? 1 : ev.buttons;\n    if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n    }\n    // buttons is a bitmask, check that the left button bit is set (1)\n    return Boolean(buttons & 1);\n  } else {\n    // allow undefined for testing events\n    let button = ev.button === undefined ? 0 : ev.button;\n    // ev.button is 0 in mousedown/mouseup/click for left button activation\n    return button === 0;\n  }\n}\n\nfunction isSyntheticClick(ev) {\n  if (ev.type === 'click') {\n    // ev.detail is 0 for HTMLElement.click in most browsers\n    if (ev.detail === 0) {\n      return true;\n    }\n    // in the worst case, check that the x/y position of the click is within\n    // the bounding box of the target of the event\n    // Thanks IE 10 >:(\n    let t = _findOriginalTarget(ev);\n    // make sure the target of the event is an element so we can use getBoundingClientRect,\n    // if not, just assume it is a synthetic click\n    if (!t.nodeType || /** @type {Element} */(t).nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    let bcr = /** @type {Element} */(t).getBoundingClientRect();\n    // use page x/y to account for scrolling\n    let x = ev.pageX, y = ev.pageY;\n    // ev is a synthetic click if the position is outside the bounding box of the target\n    return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));\n  }\n  return false;\n}\n\nlet POINTERSTATE = {\n  mouse: {\n    target: null,\n    mouseIgnoreJob: null\n  },\n  touch: {\n    x: 0,\n    y: 0,\n    id: -1,\n    scrollDecided: false\n  }\n};\n\nfunction firstTouchAction(ev) {\n  let ta = 'auto';\n  let path = getComposedPath(ev);\n  for (let i = 0, n; i < path.length; i++) {\n    n = path[i];\n    if (n[TOUCH_ACTION]) {\n      ta = n[TOUCH_ACTION];\n      break;\n    }\n  }\n  return ta;\n}\n\nfunction trackDocument(stateObj, movefn, upfn) {\n  stateObj.movefn = movefn;\n  stateObj.upfn = upfn;\n  document.addEventListener('mousemove', movefn);\n  document.addEventListener('mouseup', upfn);\n}\n\nfunction untrackDocument(stateObj) {\n  document.removeEventListener('mousemove', stateObj.movefn);\n  document.removeEventListener('mouseup', stateObj.upfn);\n  stateObj.movefn = null;\n  stateObj.upfn = null;\n}\n\n// use a document-wide touchend listener to start the ghost-click prevention mechanism\n// Use passive event listeners, if supported, to not affect scrolling performance\ndocument.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? {passive: true} : false);\n\n/**\n * Returns the composedPath for the given event.\n * @param {Event} event to process\n * @return {!Array<!EventTarget>} Path of the event\n */\nconst getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ?\n  window.ShadyDOM.composedPath :\n  (event) => event.composedPath && event.composedPath() || [];\n\n/** @type {!Object<string, !GestureRecognizer>} */\nexport const gestures = {};\n\n/** @type {!Array<!GestureRecognizer>} */\nexport const recognizers = [];\n\n/**\n * Finds the element rendered on the screen at the provided coordinates.\n *\n * Similar to `document.elementFromPoint`, but pierces through\n * shadow roots.\n *\n * @param {number} x Horizontal pixel coordinate\n * @param {number} y Vertical pixel coordinate\n * @return {Element} Returns the deepest shadowRoot inclusive element\n * found at the screen position given.\n */\nexport function deepTargetFind(x, y) {\n  let node = document.elementFromPoint(x, y);\n  let next = node;\n  // this code path is only taken when native ShadowDOM is used\n  // if there is a shadowroot, it may have a node at x/y\n  // if there is not a shadowroot, exit the loop\n  while (next && next.shadowRoot && !window.ShadyDOM) {\n    // if there is a node at x/y in the shadowroot, look deeper\n    let oldNext = next;\n    next = next.shadowRoot.elementFromPoint(x, y);\n    // on Safari, elementFromPoint may return the shadowRoot host\n    if (oldNext === next) {\n      break;\n    }\n    if (next) {\n      node = next;\n    }\n  }\n  return node;\n}\n\n/**\n * a cheaper check than ev.composedPath()[0];\n *\n * @private\n * @param {Event|Touch} ev Event.\n * @return {EventTarget} Returns the event target.\n */\nfunction _findOriginalTarget(ev) {\n  const path = getComposedPath(/** @type {?Event} */ (ev));\n  // It shouldn't be, but sometimes path is empty (window on Safari).\n  return path.length > 0 ? path[0] : ev.target;\n}\n\n/**\n * @private\n * @param {Event} ev Event.\n * @return {void}\n */\nfunction _handleNative(ev) {\n  let handled;\n  let type = ev.type;\n  let node = ev.currentTarget;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    return;\n  }\n  let gs = gobj[type];\n  if (!gs) {\n    return;\n  }\n  if (!ev[HANDLED_OBJ]) {\n    ev[HANDLED_OBJ] = {};\n    if (type.slice(0, 5) === 'touch') {\n      ev = /** @type {TouchEvent} */(ev); // eslint-disable-line no-self-assign\n      let t = ev.changedTouches[0];\n      if (type === 'touchstart') {\n        // only handle the first finger\n        if (ev.touches.length === 1) {\n          POINTERSTATE.touch.id = t.identifier;\n        }\n      }\n      if (POINTERSTATE.touch.id !== t.identifier) {\n        return;\n      }\n      if (!HAS_NATIVE_TA) {\n        if (type === 'touchstart' || type === 'touchmove') {\n          _handleTouchAction(ev);\n        }\n      }\n    }\n  }\n  handled = ev[HANDLED_OBJ];\n  // used to ignore synthetic mouse events\n  if (handled.skip) {\n    return;\n  }\n  // reset recognizer state\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\n        r.reset();\n      }\n    }\n  }\n  // enforce gesture recognizer order\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      handled[r.name] = true;\n      r[type](ev);\n    }\n  }\n}\n\n/**\n * @private\n * @param {TouchEvent} ev Event.\n * @return {void}\n */\nfunction _handleTouchAction(ev) {\n  let t = ev.changedTouches[0];\n  let type = ev.type;\n  if (type === 'touchstart') {\n    POINTERSTATE.touch.x = t.clientX;\n    POINTERSTATE.touch.y = t.clientY;\n    POINTERSTATE.touch.scrollDecided = false;\n  } else if (type === 'touchmove') {\n    if (POINTERSTATE.touch.scrollDecided) {\n      return;\n    }\n    POINTERSTATE.touch.scrollDecided = true;\n    let ta = firstTouchAction(ev);\n    let shouldPrevent = false;\n    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\n    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\n    if (!ev.cancelable) {\n      // scrolling is happening\n    } else if (ta === 'none') {\n      shouldPrevent = true;\n    } else if (ta === 'pan-x') {\n      shouldPrevent = dy > dx;\n    } else if (ta === 'pan-y') {\n      shouldPrevent = dx > dy;\n    }\n    if (shouldPrevent) {\n      ev.preventDefault();\n    } else {\n      prevent('track');\n    }\n  }\n}\n\n/**\n * Adds an event listener to a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to add listener on\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function to call\n * @return {boolean} Returns true if a gesture event listener was added.\n */\nexport function addListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _add(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes an event listener from a node for the given gesture type.\n *\n * @param {!EventTarget} node Node to remove listener from\n * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`\n * @param {!function(!Event):void} handler Event listener function previously passed to\n *  `addListener`.\n * @return {boolean} Returns true if a gesture event listener was removed.\n */\nexport function removeListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _remove(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\n/**\n * automate the event listeners for the native events\n *\n * @private\n * @param {!EventTarget} node Node on which to add the event.\n * @param {string} evType Event type to add.\n * @param {function(!Event)} handler Event handler function.\n * @return {void}\n */\nfunction _add(node, evType, handler) {\n  let recognizer = gestures[evType];\n  let deps = recognizer.deps;\n  let name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    node[GESTURE_KEY] = gobj = {};\n  }\n  for (let i = 0, dep, gd; i < deps.length; i++) {\n    dep = deps[i];\n    // don't add mouse handlers on iOS because they cause gray selection overlays\n    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {\n      continue;\n    }\n    gd = gobj[dep];\n    if (!gd) {\n      gobj[dep] = gd = {_count: 0};\n    }\n    if (gd._count === 0) {\n      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n    }\n    gd[name] = (gd[name] || 0) + 1;\n    gd._count = (gd._count || 0) + 1;\n  }\n  node.addEventListener(evType, handler);\n  if (recognizer.touchAction) {\n    setTouchAction(node, recognizer.touchAction);\n  }\n}\n\n/**\n * automate event listener removal for native events\n *\n * @private\n * @param {!EventTarget} node Node on which to remove the event.\n * @param {string} evType Event type to remove.\n * @param {function(!Event): void} handler Event handler function.\n * @return {void}\n */\nfunction _remove(node, evType, handler) {\n  let recognizer = gestures[evType];\n  let deps = recognizer.deps;\n  let name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (gobj) {\n    for (let i = 0, dep, gd; i < deps.length; i++) {\n      dep = deps[i];\n      gd = gobj[dep];\n      if (gd && gd[name]) {\n        gd[name] = (gd[name] || 1) - 1;\n        gd._count = (gd._count || 1) - 1;\n        if (gd._count === 0) {\n          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));\n        }\n      }\n    }\n  }\n  node.removeEventListener(evType, handler);\n}\n\n/**\n * Registers a new gesture event recognizer for adding new custom\n * gesture event types.\n *\n * @param {!GestureRecognizer} recog Gesture recognizer descriptor\n * @return {void}\n */\nexport function register(recog) {\n  recognizers.push(recog);\n  for (let i = 0; i < recog.emits.length; i++) {\n    gestures[recog.emits[i]] = recog;\n  }\n}\n\n/**\n * @private\n * @param {string} evName Event name.\n * @return {Object} Returns the gesture for the given event name.\n */\nfunction _findRecognizerByEvent(evName) {\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    for (let j = 0, n; j < r.emits.length; j++) {\n      n = r.emits[j];\n      if (n === evName) {\n        return r;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Sets scrolling direction on node.\n *\n * This value is checked on first move, thus it should be called prior to\n * adding event listeners.\n *\n * @param {!EventTarget} node Node to set touch action setting on\n * @param {string} value Touch action value\n * @return {void}\n */\nexport function setTouchAction(node, value) {\n  if (HAS_NATIVE_TA && node instanceof HTMLElement) {\n    // NOTE: add touchAction async so that events can be added in\n    // custom element constructors. Otherwise we run afoul of custom\n    // elements restriction against settings attributes (style) in the\n    // constructor.\n    microTask.run(() => {\n      node.style.touchAction = value;\n    });\n  }\n  node[TOUCH_ACTION] = value;\n}\n\n/**\n * Dispatches an event on the `target` element of `type` with the given\n * `detail`.\n * @private\n * @param {!EventTarget} target The element on which to fire an event.\n * @param {string} type The type of event to fire.\n * @param {!Object=} detail The detail object to populate on the event.\n * @return {void}\n */\nfunction _fire(target, type, detail) {\n  let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });\n  ev.detail = detail;\n  wrap(/** @type {!Node} */(target)).dispatchEvent(ev);\n  // forward `preventDefault` in a clean way\n  if (ev.defaultPrevented) {\n    let preventer = detail.preventer || detail.sourceEvent;\n    if (preventer && preventer.preventDefault) {\n      preventer.preventDefault();\n    }\n  }\n}\n\n/**\n * Prevents the dispatch and default action of the given event name.\n *\n * @param {string} evName Event name.\n * @return {void}\n */\nexport function prevent(evName) {\n  let recognizer = _findRecognizerByEvent(evName);\n  if (recognizer.info) {\n    recognizer.info.prevent = true;\n  }\n}\n\n/**\n * Reset the 2500ms timeout on processing mouse input after detecting touch input.\n *\n * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.\n * This method should only be called during testing with simulated touch inputs.\n * Calling this method in production may cause duplicate taps or other Gestures.\n *\n * @return {void}\n */\nexport function resetMouseCanceller() {\n  if (POINTERSTATE.mouse.mouseIgnoreJob) {\n    POINTERSTATE.mouse.mouseIgnoreJob.flush();\n  }\n}\n\n/* eslint-disable valid-jsdoc */\n\nregister({\n  name: 'downup',\n  deps: ['mousedown', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['down', 'up'],\n\n  info: {\n    movefn: null,\n    upfn: null\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function() {\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    let t = _findOriginalTarget(e);\n    let self = this;\n    let movefn = function movefn(e) {\n      if (!hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n        untrackDocument(self.info);\n      }\n    };\n    let upfn = function upfn(e) {\n      if (hasLeftMouseButton(e)) {\n        downupFire('up', t, e);\n      }\n      untrackDocument(self.info);\n    };\n    trackDocument(this.info, movefn, upfn);\n    downupFire('down', t, e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function(e) {\n    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function(e) {\n    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);\n  }\n});\n\n/**\n * @param {string} type\n * @param {EventTarget} target\n * @param {Event|Touch} event\n * @param {Event=} preventer\n * @return {void}\n */\nfunction downupFire(type, target, event, preventer) {\n  if (!target) {\n    return;\n  }\n  _fire(target, type, {\n    x: event.clientX,\n    y: event.clientY,\n    sourceEvent: event,\n    preventer: preventer,\n    prevent: function(e) {\n      return prevent(e);\n    }\n  });\n}\n\nregister({\n  name: 'track',\n  touchAction: 'none',\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['track'],\n\n  info: {\n    x: 0,\n    y: 0,\n    state: 'start',\n    started: false,\n    moves: [],\n    /** @this {GestureInfo} */\n    addMove: function(move) {\n      if (this.moves.length > TRACK_LENGTH) {\n        this.moves.shift();\n      }\n      this.moves.push(move);\n    },\n    movefn: null,\n    upfn: null,\n    prevent: false\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function() {\n    this.info.state = 'start';\n    this.info.started = false;\n    this.info.moves = [];\n    this.info.x = 0;\n    this.info.y = 0;\n    this.info.prevent = false;\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    let t = _findOriginalTarget(e);\n    let self = this;\n    let movefn = function movefn(e) {\n      let x = e.clientX, y = e.clientY;\n      if (trackHasMovedEnough(self.info, x, y)) {\n        // first move is 'start', subsequent moves are 'move', mouseup is 'end'\n        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';\n        if (self.info.state === 'start') {\n          // if and only if tracking, always prevent tap\n          prevent('tap');\n        }\n        self.info.addMove({x: x, y: y});\n        if (!hasLeftMouseButton(e)) {\n          // always fire \"end\"\n          self.info.state = 'end';\n          untrackDocument(self.info);\n        }\n        if (t) {\n          trackFire(self.info, t, e);\n        }\n        self.info.started = true;\n      }\n    };\n    let upfn = function upfn(e) {\n      if (self.info.started) {\n        movefn(e);\n      }\n\n      // remove the temporary listeners\n      untrackDocument(self.info);\n    };\n    // add temporary document listeners as mouse retargets\n    trackDocument(this.info, movefn, upfn);\n    this.info.x = e.clientX;\n    this.info.y = e.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function(e) {\n    let ct = e.changedTouches[0];\n    this.info.x = ct.clientX;\n    this.info.y = ct.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchmove: function(e) {\n    let t = _findOriginalTarget(e);\n    let ct = e.changedTouches[0];\n    let x = ct.clientX, y = ct.clientY;\n    if (trackHasMovedEnough(this.info, x, y)) {\n      if (this.info.state === 'start') {\n        // if and only if tracking, always prevent tap\n        prevent('tap');\n      }\n      this.info.addMove({x: x, y: y});\n      trackFire(this.info, t, ct);\n      this.info.state = 'track';\n      this.info.started = true;\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function(e) {\n    let t = _findOriginalTarget(e);\n    let ct = e.changedTouches[0];\n    // only trackend if track was started and not aborted\n    if (this.info.started) {\n      // reset started state on up\n      this.info.state = 'end';\n      this.info.addMove({x: ct.clientX, y: ct.clientY});\n      trackFire(this.info, t, ct);\n    }\n  }\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction trackHasMovedEnough(info, x, y) {\n  if (info.prevent) {\n    return false;\n  }\n  if (info.started) {\n    return true;\n  }\n  let dx = Math.abs(info.x - x);\n  let dy = Math.abs(info.y - y);\n  return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);\n}\n\n/**\n * @param {!GestureInfo} info\n * @param {?EventTarget} target\n * @param {Touch} touch\n * @return {void}\n */\nfunction trackFire(info, target, touch) {\n  if (!target) {\n    return;\n  }\n  let secondlast = info.moves[info.moves.length - 2];\n  let lastmove = info.moves[info.moves.length - 1];\n  let dx = lastmove.x - info.x;\n  let dy = lastmove.y - info.y;\n  let ddx, ddy = 0;\n  if (secondlast) {\n    ddx = lastmove.x - secondlast.x;\n    ddy = lastmove.y - secondlast.y;\n  }\n  _fire(target, 'track', {\n    state: info.state,\n    x: touch.clientX,\n    y: touch.clientY,\n    dx: dx,\n    dy: dy,\n    ddx: ddx,\n    ddy: ddy,\n    sourceEvent: touch,\n    hover: function() {\n      return deepTargetFind(touch.clientX, touch.clientY);\n    }\n  });\n}\n\nregister({\n  name: 'tap',\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['click', 'touchend']\n  },\n  emits: ['tap'],\n  info: {\n    x: NaN,\n    y: NaN,\n    prevent: false\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @return {void}\n   */\n  reset: function() {\n    this.info.x = NaN;\n    this.info.y = NaN;\n    this.info.prevent = false;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  mousedown: function(e) {\n    if (hasLeftMouseButton(e)) {\n      this.info.x = e.clientX;\n      this.info.y = e.clientY;\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   * @return {void}\n   */\n  click: function(e) {\n    if (hasLeftMouseButton(e)) {\n      trackForward(this.info, e);\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchstart: function(e) {\n    const touch = e.changedTouches[0];\n    this.info.x = touch.clientX;\n    this.info.y = touch.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   * @return {void}\n   */\n  touchend: function(e) {\n    trackForward(this.info, e.changedTouches[0], e);\n  }\n});\n\n/**\n * @param {!GestureInfo} info\n * @param {Event | Touch} e\n * @param {Event=} preventer\n * @return {void}\n */\nfunction trackForward(info, e, preventer) {\n  let dx = Math.abs(e.clientX - info.x);\n  let dy = Math.abs(e.clientY - info.y);\n  // find original target from `preventer` for TouchEvents, or `e` for MouseEvents\n  let t = _findOriginalTarget((preventer || e));\n  if (!t || (canBeDisabled[/** @type {!HTMLElement} */(t).localName] && t.hasAttribute('disabled'))) {\n    return;\n  }\n  // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\n  if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {\n    // prevent taps from being generated if an event has canceled them\n    if (!info.prevent) {\n      _fire(t, 'tap', {\n        x: e.clientX,\n        y: e.clientY,\n        sourceEvent: e,\n        preventer: preventer\n      });\n    }\n  }\n}\n\n/* eslint-enable valid-jsdoc */\n\n/** @deprecated */\nexport const findOriginalTarget = _findOriginalTarget;\n\n/** @deprecated */\nexport const add = addListener;\n\n/** @deprecated */\nexport const remove = removeListener;\n"],
  "mappings": "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",
  "names": []
}
