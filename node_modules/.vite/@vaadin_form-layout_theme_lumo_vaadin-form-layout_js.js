import {
  IronResizableBehavior
} from "./chunk-RA7SNJPZ.js";
import {
  mixinBehaviors
} from "./chunk-F75XGNCT.js";
import "./chunk-VXX3KNUF.js";
import "./chunk-IKTX77KG.js";
import "./chunk-EHF6M5CD.js";
import "./chunk-KFEHHBXX.js";
import "./chunk-GLSLTN6S.js";
import {
  beforeNextRender
} from "./chunk-5SUV3F4B.js";
import {
  FlattenedNodesObserver
} from "./chunk-WAPH3RCZ.js";
import "./chunk-3GXLJMXG.js";
import "./chunk-XLE2I272.js";
import "./chunk-CGDXGGUU.js";
import {
  ElementMixin
} from "./chunk-QS3SH3AF.js";
import "./chunk-4CGZWSB2.js";
import "./chunk-235CFYIT.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-FZIWHSOX.js";
import "./chunk-MQRWSCDX.js";
import "./chunk-JZ7X4XI4.js";
import {
  css
} from "./chunk-TZPBKG4Y.js";
import "./chunk-EWT3K5KQ.js";
import {
  PolymerElement
} from "./chunk-RZW6ORFJ.js";
import {
  html
} from "./chunk-5VJMXRGB.js";
import "./chunk-XALJ24ZG.js";
import "./chunk-GN24F3WZ.js";
import "./chunk-HDWYYSVS.js";
import "./chunk-PN57JW3E.js";
import "./chunk-FHJNRKKV.js";
import "./chunk-PHKVH5MM.js";
import "./chunk-GWBPVOL2.js";

// node_modules/.pnpm/@vaadin/form-layout@22.0.2/node_modules/@vaadin/form-layout/theme/lumo/vaadin-form-layout-styles.js
registerStyles("vaadin-form-layout", css`
    :host {
      --vaadin-form-layout-column-spacing: var(--lumo-space-l);
    }
  `, { moduleId: "lumo-form-layout" });

// node_modules/.pnpm/@vaadin/form-layout@22.0.2/node_modules/@vaadin/form-layout/src/vaadin-form-layout.js
var FormLayout = class extends ElementMixin(ThemableMixin(mixinBehaviors([IronResizableBehavior], PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          max-width: 100%;
          animation: 1ms vaadin-form-layout-appear;
          /* CSS API for host */
          --vaadin-form-item-label-width: 8em;
          --vaadin-form-item-label-spacing: 1em;
          --vaadin-form-item-row-spacing: 1em;
          --vaadin-form-layout-column-spacing: 2em; /* (default) */
          align-self: stretch;
        }

        @keyframes vaadin-form-layout-appear {
          to {
            opacity: 1 !important; /* stylelint-disable-line keyframe-declaration-no-important */
          }
        }

        :host([hidden]) {
          display: none !important;
        }

        #layout {
          display: flex;

          align-items: baseline; /* default \`stretch\` is not appropriate */

          flex-wrap: wrap; /* the items should wrap */
        }

        #layout ::slotted(*) {
          /* Items should neither grow nor shrink. */
          flex-grow: 0;
          flex-shrink: 0;

          /* Margins make spacing between the columns */
          margin-left: calc(0.5 * var(--vaadin-form-layout-column-spacing));
          margin-right: calc(0.5 * var(--vaadin-form-layout-column-spacing));
        }

        #layout ::slotted(br) {
          display: none;
        }
      </style>
      <div id="layout">
        <slot id="slot"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-form-layout";
  }
  static get properties() {
    return {
      responsiveSteps: {
        type: Array,
        value: function() {
          return [
            { minWidth: 0, columns: 1, labelsPosition: "top" },
            { minWidth: "20em", columns: 1 },
            { minWidth: "40em", columns: 2 }
          ];
        },
        observer: "_responsiveStepsChanged"
      },
      _columnCount: {
        type: Number
      },
      _labelsOnTop: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["_invokeUpdateStyles(_columnCount, _labelsOnTop)"];
  }
  ready() {
    this._styleElement = document.createElement("style");
    this.root.appendChild(this._styleElement);
    this._styleElement.textContent = " ";
    super.ready();
    this.addEventListener("iron-resize", this._selectResponsiveStep);
    this.addEventListener("animationend", this.__onAnimationEnd);
  }
  connectedCallback() {
    super.connectedCallback();
    beforeNextRender(this, this._selectResponsiveStep);
    beforeNextRender(this, this.updateStyles);
    this._observeChildrenColspanChange();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__mutationObserver.disconnect();
    this.__childObserver.disconnect();
  }
  _observeChildrenColspanChange() {
    const mutationObserverConfig = { attributes: true };
    this.__mutationObserver = new MutationObserver((mutationRecord) => {
      mutationRecord.forEach((mutation) => {
        if (mutation.type === "attributes" && (mutation.attributeName === "colspan" || mutation.attributeName === "hidden")) {
          this.updateStyles();
        }
      });
    });
    this.__childObserver = new FlattenedNodesObserver(this, (info) => {
      const addedNodes = this._getObservableNodes(info.addedNodes);
      const removedNodes = this._getObservableNodes(info.removedNodes);
      addedNodes.forEach((child) => {
        this.__mutationObserver.observe(child, mutationObserverConfig);
      });
      if (addedNodes.length > 0 || removedNodes.length > 0) {
        this.updateStyles();
      }
    });
  }
  _getObservableNodes(nodeList) {
    const ignore = ["template", "style", "dom-repeat", "dom-if"];
    return Array.from(nodeList).filter((node) => node.nodeType === Node.ELEMENT_NODE && ignore.indexOf(node.localName.toLowerCase()) === -1);
  }
  _naturalNumberOrOne(n) {
    if (typeof n === "number" && n >= 1 && n < Infinity) {
      return Math.floor(n);
    }
    return 1;
  }
  _isValidCSSLength(value) {
    if (value === "inherit" || value === "normal") {
      return false;
    }
    this._styleElement.firstChild.nodeValue = `#styleElement { word-spacing: ${value}; }`;
    if (!this._styleElement.sheet) {
      return true;
    }
    return ["", null].indexOf(this._styleElement.sheet.cssRules[0].style.getPropertyValue("word-spacing")) < 0;
  }
  _responsiveStepsChanged(responsiveSteps, oldResponsiveSteps) {
    try {
      if (!Array.isArray(responsiveSteps)) {
        throw new Error('Invalid "responsiveSteps" type, an Array is required.');
      }
      if (responsiveSteps.length < 1) {
        throw new Error('Invalid empty "responsiveSteps" array, at least one item is required.');
      }
      responsiveSteps.forEach((step) => {
        if (this._naturalNumberOrOne(step.columns) !== step.columns) {
          throw new Error(`Invalid 'columns' value of ${step.columns}, a natural number is required.`);
        }
        if (step.minWidth !== void 0 && !this._isValidCSSLength(step.minWidth)) {
          throw new Error(`Invalid 'minWidth' value of ${step.minWidth}, a valid CSS length required.`);
        }
        if (step.labelsPosition !== void 0 && ["aside", "top"].indexOf(step.labelsPosition) === -1) {
          throw new Error(`Invalid 'labelsPosition' value of ${step.labelsPosition}, 'aside' or 'top' string is required.`);
        }
      });
    } catch (e) {
      if (oldResponsiveSteps && oldResponsiveSteps !== responsiveSteps) {
        console.warn(`${e.message} Using previously set 'responsiveSteps' instead.`);
        this.responsiveSteps = oldResponsiveSteps;
      } else {
        console.warn(`${e.message} Using default 'responsiveSteps' instead.`);
        this.responsiveSteps = [
          { minWidth: 0, columns: 1, labelsPosition: "top" },
          { minWidth: "20em", columns: 1 },
          { minWidth: "40em", columns: 2 }
        ];
      }
    }
    this._selectResponsiveStep();
  }
  __onAnimationEnd(e) {
    if (e.animationName.indexOf("vaadin-form-layout-appear") === 0) {
      this._selectResponsiveStep();
    }
  }
  _selectResponsiveStep() {
    let selectedStep;
    const tmpStyleProp = "background-position";
    this.responsiveSteps.forEach((step) => {
      this.$.layout.style.setProperty(tmpStyleProp, step.minWidth);
      const stepMinWidthPx = parseFloat(getComputedStyle(this.$.layout).getPropertyValue(tmpStyleProp));
      if (stepMinWidthPx <= this.offsetWidth) {
        selectedStep = step;
      }
    });
    this.$.layout.style.removeProperty(tmpStyleProp);
    if (selectedStep) {
      this._columnCount = selectedStep.columns;
      this._labelsOnTop = selectedStep.labelsPosition === "top";
    }
  }
  _invokeUpdateStyles() {
    this.updateStyles();
  }
  updateStyles(properties) {
    super.updateStyles(properties);
    const style = getComputedStyle(this);
    const columnSpacing = style.getPropertyValue("--vaadin-form-layout-column-spacing");
    const direction = style.direction;
    const marginStartProp = "margin-" + (direction === "ltr" ? "left" : "right");
    const marginEndProp = "margin-" + (direction === "ltr" ? "right" : "left");
    const containerWidth = this.offsetWidth;
    let col = 0;
    Array.from(this.children).filter((child) => child.localName === "br" || getComputedStyle(child).display !== "none").forEach((child, index, children) => {
      if (child.localName === "br") {
        col = 0;
        return;
      }
      let colspan;
      colspan = this._naturalNumberOrOne(parseFloat(child.getAttribute("colspan")));
      colspan = Math.min(colspan, this._columnCount);
      const childRatio = colspan / this._columnCount;
      child.style.width = `calc(${childRatio * 99.9}% - ${1 - childRatio} * ${columnSpacing})`;
      if (col + colspan > this._columnCount) {
        col = 0;
      }
      if (col === 0) {
        child.style.setProperty(marginStartProp, "0px");
      } else {
        child.style.removeProperty(marginStartProp);
      }
      const nextIndex = index + 1;
      const nextLineBreak = nextIndex < children.length && children[nextIndex].localName === "br";
      if (col + colspan === this._columnCount) {
        child.style.setProperty(marginEndProp, "0px");
      } else if (nextLineBreak) {
        const colspanRatio = (this._columnCount - col - colspan) / this._columnCount;
        child.style.setProperty(marginEndProp, `calc(${colspanRatio * containerWidth}px + ${colspanRatio} * ${columnSpacing})`);
      } else {
        child.style.removeProperty(marginEndProp);
      }
      col = (col + colspan) % this._columnCount;
      if (child.localName === "vaadin-form-item") {
        if (this._labelsOnTop) {
          child.setAttribute("label-position", "top");
        } else {
          child.removeAttribute("label-position");
        }
      }
    });
  }
};
customElements.define(FormLayout.is, FormLayout);
/**
 * @license
 * Copyright (c) 2021 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_form-layout_theme_lumo_vaadin-form-layout_js.js.map
