{
  "version": 3,
  "sources": ["../.pnpm/@vaadin/vaadin-list-mixin@22.0.2/node_modules/@vaadin/vaadin-list-mixin/vaadin-list-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\nimport { timeOut } from '@vaadin/component-base/src/async.js';\nimport { Debouncer } from '@vaadin/component-base/src/debounce.js';\nimport { DirHelper } from '@vaadin/component-base/src/dir-helper.js';\n\n/**\n * A mixin for `nav` elements, facilitating navigation and selection of childNodes.\n *\n * @polymerMixin\n */\nexport const ListMixin = (superClass) =>\n  class VaadinListMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * Used for mixin detection because `instanceof` does not work with mixins.\n         * @type {boolean}\n         */\n        _hasVaadinListMixin: {\n          value: true\n        },\n\n        /**\n         * The index of the item selected in the items array.\n         * Note: Not updated when used in `multiple` selection mode.\n         */\n        selected: {\n          type: Number,\n          reflectToAttribute: true,\n          notify: true\n        },\n\n        /**\n         * Define how items are disposed in the dom.\n         * Possible values are: `horizontal|vertical`.\n         * It also changes navigation keys from left/right to up/down.\n         * @type {!ListOrientation}\n         */\n        orientation: {\n          type: String,\n          reflectToAttribute: true,\n          value: ''\n        },\n\n        /**\n         * The list of items from which a selection can be made.\n         * It is populated from the elements passed to the light DOM,\n         * and updated dynamically when adding or removing items.\n         *\n         * The item elements must implement `Vaadin.ItemMixin`.\n         *\n         * Note: unlike `<vaadin-combo-box>`, this property is read-only,\n         * so if you want to provide items by iterating array of data,\n         * you have to use `dom-repeat` and place it to the light DOM.\n         * @type {!Array<!Element> | undefined}\n         */\n        items: {\n          type: Array,\n          readOnly: true,\n          notify: true\n        },\n\n        /**\n         * The search buffer for the keyboard selection feature.\n         * @private\n         */\n        _searchBuf: {\n          type: String,\n          value: ''\n        }\n      };\n    }\n\n    static get observers() {\n      return ['_enhanceItems(items, orientation, selected, disabled)'];\n    }\n\n    /** @protected */\n    ready() {\n      super.ready();\n      this.addEventListener('keydown', (e) => this._onKeydown(e));\n      this.addEventListener('click', (e) => this._onClick(e));\n\n      this._observer = new FlattenedNodesObserver(this, () => {\n        this._setItems(this._filterItems(Array.from(this.children)));\n      });\n    }\n\n    /** @private */\n    _enhanceItems(items, orientation, selected, disabled) {\n      if (!disabled) {\n        if (items) {\n          this.setAttribute('aria-orientation', orientation || 'vertical');\n          this.items.forEach((item) => {\n            orientation ? item.setAttribute('orientation', orientation) : item.removeAttribute('orientation');\n          });\n\n          this._setFocusable(selected || 0);\n\n          const itemToSelect = items[selected];\n          items.forEach((item) => (item.selected = item === itemToSelect));\n          if (itemToSelect && !itemToSelect.disabled) {\n            this._scrollToItem(selected);\n          }\n        }\n      }\n    }\n\n    /**\n     * @return {Element}\n     */\n    get focused() {\n      return this.getRootNode().activeElement;\n    }\n\n    /**\n     * @param {!Array<!Element>} array\n     * @return {!Array<!Element>}\n     * @protected\n     */\n    _filterItems(array) {\n      return array.filter((e) => e._hasVaadinItemMixin);\n    }\n\n    /**\n     * @param {!MouseEvent} event\n     * @protected\n     */\n    _onClick(event) {\n      if (event.metaKey || event.shiftKey || event.ctrlKey || event.defaultPrevented) {\n        return;\n      }\n\n      const item = this._filterItems(event.composedPath())[0];\n      let idx;\n      if (item && !item.disabled && (idx = this.items.indexOf(item)) >= 0) {\n        this.selected = idx;\n      }\n    }\n\n    /**\n     * @param {number} currentIdx\n     * @param {string} key\n     * @return {number}\n     * @protected\n     */\n    _searchKey(currentIdx, key) {\n      this._searchReset = Debouncer.debounce(this._searchReset, timeOut.after(500), () => (this._searchBuf = ''));\n      this._searchBuf += key.toLowerCase();\n      const increment = 1;\n      const condition = (item) =>\n        !(item.disabled || this._isItemHidden(item)) &&\n        item.textContent\n          .replace(/[^\\p{L}\\p{Nd}]/gu, '')\n          .toLowerCase()\n          .indexOf(this._searchBuf) === 0;\n\n      if (\n        !this.items.some(\n          (item) =>\n            item.textContent\n              .replace(/[^\\p{L}\\p{Nd}]/gu, '')\n              .toLowerCase()\n              .indexOf(this._searchBuf) === 0\n        )\n      ) {\n        this._searchBuf = key.toLowerCase();\n      }\n\n      const idx = this._searchBuf.length === 1 ? currentIdx + 1 : currentIdx;\n      return this._getAvailableIndex(idx, increment, condition);\n    }\n\n    /**\n     * @return {boolean}\n     * @protected\n     */\n    get _isRTL() {\n      return !this._vertical && this.getAttribute('dir') === 'rtl';\n    }\n\n    /**\n     * @param {!KeyboardEvent} event\n     * @protected\n     */\n    _onKeydown(event) {\n      if (event.metaKey || event.ctrlKey) {\n        return;\n      }\n\n      const key = event.key;\n\n      const currentIdx = this.items.indexOf(this.focused);\n\n      if (/[a-zA-Z0-9]/.test(key) && key.length === 1) {\n        const idx = this._searchKey(currentIdx, key);\n        if (idx >= 0) {\n          this._focus(idx);\n        }\n        return;\n      }\n\n      const condition = (item) => !(item.disabled || this._isItemHidden(item));\n      let idx, increment;\n\n      const dirIncrement = this._isRTL ? -1 : 1;\n\n      if ((this._vertical && key === 'ArrowUp') || (!this._vertical && key === 'ArrowLeft')) {\n        increment = -dirIncrement;\n        idx = currentIdx - dirIncrement;\n      } else if ((this._vertical && key === 'ArrowDown') || (!this._vertical && key === 'ArrowRight')) {\n        increment = dirIncrement;\n        idx = currentIdx + dirIncrement;\n      } else if (key === 'Home') {\n        increment = 1;\n        idx = 0;\n      } else if (key === 'End') {\n        increment = -1;\n        idx = this.items.length - 1;\n      }\n\n      idx = this._getAvailableIndex(idx, increment, condition);\n      if (idx >= 0) {\n        this._focus(idx);\n        event.preventDefault();\n      }\n    }\n\n    /**\n     * @param {number} idx\n     * @param {number} increment\n     * @param {function(!Element):boolean} condition\n     * @return {number}\n     * @protected\n     */\n    _getAvailableIndex(idx, increment, condition) {\n      const totalItems = this.items.length;\n      for (let i = 0; typeof idx == 'number' && i < totalItems; i++, idx += increment || 1) {\n        if (idx < 0) {\n          idx = totalItems - 1;\n        } else if (idx >= totalItems) {\n          idx = 0;\n        }\n\n        const item = this.items[idx];\n\n        if (condition(item)) {\n          return idx;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * @param {!Element} item\n     * @return {boolean}\n     * @protected\n     */\n    _isItemHidden(item) {\n      return getComputedStyle(item).display === 'none';\n    }\n\n    /**\n     * @param {number} idx\n     * @protected\n     */\n    _setFocusable(idx) {\n      idx = this._getAvailableIndex(idx, 1, (item) => !item.disabled);\n      const item = this.items[idx];\n      this.items.forEach((e) => (e.tabIndex = e === item ? 0 : -1));\n    }\n\n    /**\n     * @param {number} idx\n     * @protected\n     */\n    _focus(idx) {\n      const item = this.items[idx];\n      this.items.forEach((e) => (e.focused = e === item));\n      this._setFocusable(idx);\n      this._scrollToItem(idx);\n      this._focusItem(item);\n    }\n\n    /**\n     * Always set focus-ring on the item managed by the list-box\n     * for backwards compatibility with the old implementation.\n     * @param {HTMLElement} item\n     * @protected\n     */\n    _focusItem(item) {\n      if (item) {\n        item.focus();\n        item.setAttribute('focus-ring', '');\n      }\n    }\n\n    focus() {\n      // In initialisation (e.g vaadin-select) observer might not been run yet.\n      this._observer && this._observer.flush();\n      const firstItem = this.querySelector('[tabindex=\"0\"]') || (this.items ? this.items[0] : null);\n      this._focusItem(firstItem);\n    }\n\n    /**\n     * @return {!HTMLElement}\n     * @protected\n     */\n    get _scrollerElement() {\n      // Returning scroller element of the component\n      console.warn(`Please implement the '_scrollerElement' property in <${this.localName}>`);\n      return this;\n    }\n\n    /**\n     * Scroll the container to have the next item by the edge of the viewport.\n     * @param {number} idx\n     * @protected\n     */\n    _scrollToItem(idx) {\n      const item = this.items[idx];\n      if (!item) {\n        return;\n      }\n\n      const props = this._vertical ? ['top', 'bottom'] : this._isRTL ? ['right', 'left'] : ['left', 'right'];\n\n      const scrollerRect = this._scrollerElement.getBoundingClientRect();\n      const nextItemRect = (this.items[idx + 1] || item).getBoundingClientRect();\n      const prevItemRect = (this.items[idx - 1] || item).getBoundingClientRect();\n\n      let scrollDistance = 0;\n      if (\n        (!this._isRTL && nextItemRect[props[1]] >= scrollerRect[props[1]]) ||\n        (this._isRTL && nextItemRect[props[1]] <= scrollerRect[props[1]])\n      ) {\n        scrollDistance = nextItemRect[props[1]] - scrollerRect[props[1]];\n      } else if (\n        (!this._isRTL && prevItemRect[props[0]] <= scrollerRect[props[0]]) ||\n        (this._isRTL && prevItemRect[props[0]] >= scrollerRect[props[0]])\n      ) {\n        scrollDistance = prevItemRect[props[0]] - scrollerRect[props[0]];\n      }\n\n      this._scroll(scrollDistance);\n    }\n\n    /**\n     * @return {boolean}\n     * @protected\n     */\n    get _vertical() {\n      return this.orientation !== 'horizontal';\n    }\n\n    /**\n     * @param {number} pixels\n     * @protected\n     */\n    _scroll(pixels) {\n      if (this._vertical) {\n        this._scrollerElement['scrollTop'] += pixels;\n      } else {\n        const dir = this.getAttribute('dir') || 'ltr';\n        const scrollType = DirHelper.detectScrollType();\n        const scrollLeft = DirHelper.getNormalizedScrollLeft(scrollType, dir, this._scrollerElement) + pixels;\n        DirHelper.setNormalizedScrollLeft(scrollType, dir, this._scrollerElement, scrollLeft);\n      }\n    }\n\n    /**\n     * Fired when the selection is changed.\n     * Not fired when used in `multiple` selection mode.\n     *\n     * @event selected-changed\n     * @param {Object} detail\n     * @param {Object} detail.value the index of the item selected in the items array.\n     */\n  };\n"],
  "mappings": ";;;;;;;;;;;;AAAA,AAeO,IAAM,YAAY,CAAC,eACxB,8BAA8B,WAAW;AAAA,aAC5B,aAAa;AACtB,WAAO;AAAA,MAKL,qBAAqB;AAAA,QACnB,OAAO;AAAA;AAAA,MAOT,UAAU;AAAA,QACR,MAAM;AAAA,QACN,oBAAoB;AAAA,QACpB,QAAQ;AAAA;AAAA,MASV,aAAa;AAAA,QACX,MAAM;AAAA,QACN,oBAAoB;AAAA,QACpB,OAAO;AAAA;AAAA,MAeT,OAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,QACV,QAAQ;AAAA;AAAA,MAOV,YAAY;AAAA,QACV,MAAM;AAAA,QACN,OAAO;AAAA;AAAA;AAAA;AAAA,aAKF,YAAY;AACrB,WAAO,CAAC;AAAA;AAAA,EAIV,QAAQ;AACN,UAAM;AACN,SAAK,iBAAiB,WAAW,CAAC,MAAM,KAAK,WAAW;AACxD,SAAK,iBAAiB,SAAS,CAAC,MAAM,KAAK,SAAS;AAEpD,SAAK,YAAY,IAAI,uBAAuB,MAAM,MAAM;AACtD,WAAK,UAAU,KAAK,aAAa,MAAM,KAAK,KAAK;AAAA;AAAA;AAAA,EAKrD,cAAc,OAAO,aAAa,UAAU,UAAU;AACpD,QAAI,CAAC,UAAU;AACb,UAAI,OAAO;AACT,aAAK,aAAa,oBAAoB,eAAe;AACrD,aAAK,MAAM,QAAQ,CAAC,SAAS;AAC3B,wBAAc,KAAK,aAAa,eAAe,eAAe,KAAK,gBAAgB;AAAA;AAGrF,aAAK,cAAc,YAAY;AAE/B,cAAM,eAAe,MAAM;AAC3B,cAAM,QAAQ,CAAC,SAAU,KAAK,WAAW,SAAS;AAClD,YAAI,gBAAgB,CAAC,aAAa,UAAU;AAC1C,eAAK,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA,MASvB,UAAU;AACZ,WAAO,KAAK,cAAc;AAAA;AAAA,EAQ5B,aAAa,OAAO;AAClB,WAAO,MAAM,OAAO,CAAC,MAAM,EAAE;AAAA;AAAA,EAO/B,SAAS,OAAO;AACd,QAAI,MAAM,WAAW,MAAM,YAAY,MAAM,WAAW,MAAM,kBAAkB;AAC9E;AAAA;AAGF,UAAM,OAAO,KAAK,aAAa,MAAM,gBAAgB;AACrD,QAAI;AACJ,QAAI,QAAQ,CAAC,KAAK,YAAa,OAAM,KAAK,MAAM,QAAQ,UAAU,GAAG;AACnE,WAAK,WAAW;AAAA;AAAA;AAAA,EAUpB,WAAW,YAAY,KAAK;AAC1B,SAAK,eAAe,UAAU,SAAS,KAAK,cAAc,QAAQ,MAAM,MAAM,MAAO,KAAK,aAAa;AACvG,SAAK,cAAc,IAAI;AACvB,UAAM,YAAY;AAClB,UAAM,YAAY,CAAC,SACjB,CAAE,MAAK,YAAY,KAAK,cAAc,UACtC,KAAK,YACF,QAAQ,oBAAoB,IAC5B,cACA,QAAQ,KAAK,gBAAgB;AAElC,QACE,CAAC,KAAK,MAAM,KACV,CAAC,SACC,KAAK,YACF,QAAQ,oBAAoB,IAC5B,cACA,QAAQ,KAAK,gBAAgB,IAEpC;AACA,WAAK,aAAa,IAAI;AAAA;AAGxB,UAAM,MAAM,KAAK,WAAW,WAAW,IAAI,aAAa,IAAI;AAC5D,WAAO,KAAK,mBAAmB,KAAK,WAAW;AAAA;AAAA,MAO7C,SAAS;AACX,WAAO,CAAC,KAAK,aAAa,KAAK,aAAa,WAAW;AAAA;AAAA,EAOzD,WAAW,OAAO;AAChB,QAAI,MAAM,WAAW,MAAM,SAAS;AAClC;AAAA;AAGF,UAAM,MAAM,MAAM;AAElB,UAAM,aAAa,KAAK,MAAM,QAAQ,KAAK;AAE3C,QAAI,cAAc,KAAK,QAAQ,IAAI,WAAW,GAAG;AAC/C,YAAM,OAAM,KAAK,WAAW,YAAY;AACxC,UAAI,QAAO,GAAG;AACZ,aAAK,OAAO;AAAA;AAEd;AAAA;AAGF,UAAM,YAAY,CAAC,SAAS,CAAE,MAAK,YAAY,KAAK,cAAc;AAClE,QAAI,KAAK;AAET,UAAM,eAAe,KAAK,SAAS,KAAK;AAExC,QAAK,KAAK,aAAa,QAAQ,aAAe,CAAC,KAAK,aAAa,QAAQ,aAAc;AACrF,kBAAY,CAAC;AACb,YAAM,aAAa;AAAA,eACT,KAAK,aAAa,QAAQ,eAAiB,CAAC,KAAK,aAAa,QAAQ,cAAe;AAC/F,kBAAY;AACZ,YAAM,aAAa;AAAA,eACV,QAAQ,QAAQ;AACzB,kBAAY;AACZ,YAAM;AAAA,eACG,QAAQ,OAAO;AACxB,kBAAY;AACZ,YAAM,KAAK,MAAM,SAAS;AAAA;AAG5B,UAAM,KAAK,mBAAmB,KAAK,WAAW;AAC9C,QAAI,OAAO,GAAG;AACZ,WAAK,OAAO;AACZ,YAAM;AAAA;AAAA;AAAA,EAWV,mBAAmB,KAAK,WAAW,WAAW;AAC5C,UAAM,aAAa,KAAK,MAAM;AAC9B,aAAS,IAAI,GAAG,OAAO,OAAO,YAAY,IAAI,YAAY,KAAK,OAAO,aAAa,GAAG;AACpF,UAAI,MAAM,GAAG;AACX,cAAM,aAAa;AAAA,iBACV,OAAO,YAAY;AAC5B,cAAM;AAAA;AAGR,YAAM,OAAO,KAAK,MAAM;AAExB,UAAI,UAAU,OAAO;AACnB,eAAO;AAAA;AAAA;AAGX,WAAO;AAAA;AAAA,EAQT,cAAc,MAAM;AAClB,WAAO,iBAAiB,MAAM,YAAY;AAAA;AAAA,EAO5C,cAAc,KAAK;AACjB,UAAM,KAAK,mBAAmB,KAAK,GAAG,CAAC,UAAS,CAAC,MAAK;AACtD,UAAM,OAAO,KAAK,MAAM;AACxB,SAAK,MAAM,QAAQ,CAAC,MAAO,EAAE,WAAW,MAAM,OAAO,IAAI;AAAA;AAAA,EAO3D,OAAO,KAAK;AACV,UAAM,OAAO,KAAK,MAAM;AACxB,SAAK,MAAM,QAAQ,CAAC,MAAO,EAAE,UAAU,MAAM;AAC7C,SAAK,cAAc;AACnB,SAAK,cAAc;AACnB,SAAK,WAAW;AAAA;AAAA,EASlB,WAAW,MAAM;AACf,QAAI,MAAM;AACR,WAAK;AACL,WAAK,aAAa,cAAc;AAAA;AAAA;AAAA,EAIpC,QAAQ;AAEN,SAAK,aAAa,KAAK,UAAU;AACjC,UAAM,YAAY,KAAK,cAAc,qBAAsB,MAAK,QAAQ,KAAK,MAAM,KAAK;AACxF,SAAK,WAAW;AAAA;AAAA,MAOd,mBAAmB;AAErB,YAAQ,KAAK,wDAAwD,KAAK;AAC1E,WAAO;AAAA;AAAA,EAQT,cAAc,KAAK;AACjB,UAAM,OAAO,KAAK,MAAM;AACxB,QAAI,CAAC,MAAM;AACT;AAAA;AAGF,UAAM,QAAQ,KAAK,YAAY,CAAC,OAAO,YAAY,KAAK,SAAS,CAAC,SAAS,UAAU,CAAC,QAAQ;AAE9F,UAAM,eAAe,KAAK,iBAAiB;AAC3C,UAAM,eAAgB,MAAK,MAAM,MAAM,MAAM,MAAM;AACnD,UAAM,eAAgB,MAAK,MAAM,MAAM,MAAM,MAAM;AAEnD,QAAI,iBAAiB;AACrB,QACG,CAAC,KAAK,UAAU,aAAa,MAAM,OAAO,aAAa,MAAM,OAC7D,KAAK,UAAU,aAAa,MAAM,OAAO,aAAa,MAAM,KAC7D;AACA,uBAAiB,aAAa,MAAM,MAAM,aAAa,MAAM;AAAA,eAE5D,CAAC,KAAK,UAAU,aAAa,MAAM,OAAO,aAAa,MAAM,OAC7D,KAAK,UAAU,aAAa,MAAM,OAAO,aAAa,MAAM,KAC7D;AACA,uBAAiB,aAAa,MAAM,MAAM,aAAa,MAAM;AAAA;AAG/D,SAAK,QAAQ;AAAA;AAAA,MAOX,YAAY;AACd,WAAO,KAAK,gBAAgB;AAAA;AAAA,EAO9B,QAAQ,QAAQ;AACd,QAAI,KAAK,WAAW;AAClB,WAAK,iBAAiB,gBAAgB;AAAA,WACjC;AACL,YAAM,MAAM,KAAK,aAAa,UAAU;AACxC,YAAM,aAAa,UAAU;AAC7B,YAAM,aAAa,UAAU,wBAAwB,YAAY,KAAK,KAAK,oBAAoB;AAC/F,gBAAU,wBAAwB,YAAY,KAAK,KAAK,kBAAkB;AAAA;AAAA;AAAA;",
  "names": []
}
