{
  "version": 3,
  "sources": ["../.pnpm/@vaadin/vaadin-themable-mixin@22.0.2/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js", "../.pnpm/@vaadin/vaadin-themable-mixin@22.0.2/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/**\n * @polymerMixin\n */\nexport const ThemePropertyMixin = (superClass) =>\n  class VaadinThemePropertyMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * Helper property with theme attribute value facilitating propagation\n         * in shadow DOM.\n         *\n         * Enables the component implementation to propagate the `theme`\n         * attribute value to the sub-components in Shadow DOM by binding\n         * the sub-component\u2019s \"theme\" attribute to the `theme` property of\n         * the host.\n         *\n         * **NOTE:** Extending the mixin only provides the property for binding,\n         * and does not make the propagation alone.\n         *\n         * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/ds/customization/styling-components/#sub-components).\n         * page for more information.\n         *\n         * @protected\n         */\n        theme: {\n          type: String,\n          readOnly: true\n        }\n      };\n    }\n\n    /** @protected */\n    attributeChangedCallback(name, oldValue, newValue) {\n      super.attributeChangedCallback(name, oldValue, newValue);\n\n      if (name === 'theme') {\n        this._setTheme(newValue);\n      }\n    }\n  };\n", "/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { css, CSSResult, unsafeCSS } from 'lit';\nimport { ThemePropertyMixin } from './vaadin-theme-property-mixin.js';\n\nexport { css, unsafeCSS };\n\n/**\n * @typedef {Object} Theme\n * @property {string} themeFor\n * @property {CSSResult[]} styles\n * @property {string | string[]} [include]\n * @property {string} [moduleId]\n *\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\n */\n\n/**\n * @type {Theme[]}\n */\nconst themeRegistry = [];\n\n/**\n * Registers CSS styles for a component type. Make sure to register the styles before\n * the first instance of a component of the type is attached to DOM.\n *\n * @param {string} themeFor The local/tag name of the component type to register the styles for\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\n * matching themeFor and included in the local scope of each component instance\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\n * @return {void}\n */\nexport function registerStyles(themeFor, styles, options = {}) {\n  if (themeFor) {\n    const elementClass = customElements.get(themeFor);\n    if (elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__finalized')) {\n      console.warn(`The custom element definition for \"${themeFor}\"\n      was finalized before a style module was registered.\n      Make sure to add component specific style modules before\n      importing the corresponding custom element.`);\n    }\n  }\n\n  styles = recursiveFlattenStyles(styles);\n\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);\n  } else {\n    themeRegistry.push({\n      themeFor,\n      styles,\n      include: options.include,\n      moduleId: options.moduleId\n    });\n  }\n}\n\n/**\n * Returns all registered themes. By default the themeRegistry is returend as is.\n * In case the style-modules adapter is imported, the themes are obtained from there instead\n * @returns {Theme[]}\n */\nfunction getAllThemes() {\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    return window.Vaadin.styleModules.getAllThemes();\n  } else {\n    return themeRegistry;\n  }\n}\n\n/**\n * Returns true if the themeFor string matches the tag name\n * @param {string} themeFor\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction matchesThemeFor(themeFor, tagName) {\n  return (themeFor || '').split(' ').some((themeForToken) => {\n    return new RegExp('^' + themeForToken.split('*').join('.*') + '$').test(tagName);\n  });\n}\n\n/**\n * Maps the moduleName to an include priority number which is used for\n * determining the order in which styles are applied.\n * @param {string} moduleName\n * @returns {number}\n */\nfunction getIncludePriority(moduleName = '') {\n  let includePriority = 0;\n  if (moduleName.indexOf('lumo-') === 0 || moduleName.indexOf('material-') === 0) {\n    includePriority = 1;\n  } else if (moduleName.indexOf('vaadin-') === 0) {\n    includePriority = 2;\n  }\n  return includePriority;\n}\n\n/**\n * Flattens the styles into a single array of styles.\n * @param {CSSResultGroup} styles\n * @param {CSSResult[]} result\n * @returns {CSSResult[]}\n */\nfunction recursiveFlattenStyles(styles = [], result = []) {\n  if (styles instanceof CSSResult) {\n    result.push(styles);\n  } else if (Array.isArray(styles)) {\n    styles.forEach((style) => recursiveFlattenStyles(style, result));\n  } else {\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\n  }\n  return result;\n}\n\n/**\n * Gets an array of CSSResults matching the include property of the theme.\n * @param {Theme} theme\n * @returns {CSSResult[]}\n */\nfunction getIncludedStyles(theme) {\n  const includedStyles = [];\n  if (theme.include) {\n    [].concat(theme.include).forEach((includeModuleId) => {\n      const includedTheme = getAllThemes().find((s) => s.moduleId === includeModuleId);\n      if (includedTheme) {\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\n      } else {\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\n      }\n    }, theme.styles);\n  }\n  return includedStyles;\n}\n\n/**\n * Includes the styles to the template.\n * @param {CSSResult[]} styles\n * @param {HTMLTemplateElement} template\n */\nfunction addStylesToTemplate(styles, template) {\n  const styleEl = document.createElement('style');\n  styleEl.innerHTML = styles\n    // Remove duplicates so that the last occurrence remains\n    .filter((style, index) => index === styles.lastIndexOf(style))\n    .map((style) => style.cssText)\n    .join('\\n');\n  template.content.appendChild(styleEl);\n}\n\n/**\n * Returns an array of themes that should be used for styling a component matching\n * the tag name. The array is sorted by the include order.\n * @param {string} tagName\n * @returns {Theme[]}\n */\nfunction getThemes(tagName) {\n  const defaultModuleName = tagName + '-default-theme';\n\n  const themes = getAllThemes()\n    // Filter by matching themeFor properties\n    .filter((theme) => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName))\n    .map((theme) => ({\n      ...theme,\n      // Prepend styles from included themes\n      styles: [...getIncludedStyles(theme), ...theme.styles],\n      // Map moduleId to includePriority\n      includePriority: getIncludePriority(theme.moduleId)\n    }))\n    // Sort by includePriority\n    .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\n\n  if (themes.length > 0) {\n    return themes;\n  } else {\n    // No theme modules found, return the default module if it exists\n    return getAllThemes().filter((theme) => theme.moduleId === defaultModuleName);\n  }\n}\n\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\nexport const ThemableMixin = (superClass) =>\n  class VaadinThemableMixin extends ThemePropertyMixin(superClass) {\n    /**\n     * Covers PolymerElement based component styling\n     * @protected\n     */\n    static finalize() {\n      super.finalize();\n\n      const template = this.prototype._template;\n      if (!template || template.__themes) {\n        return;\n      }\n\n      const inheritedTemplate = Object.getPrototypeOf(this.prototype)._template;\n      const inheritedThemes = (inheritedTemplate ? inheritedTemplate.__themes : []) || [];\n\n      template.__themes = [...inheritedThemes, ...getThemes(this.is)];\n\n      // Get flattened styles array\n      const styles = template.__themes.reduce((styles, theme) => [...styles, ...theme.styles], []);\n      addStylesToTemplate(styles, template);\n    }\n\n    /**\n     * Covers LitElement based component styling\n     *\n     * NOTE: This is not yet an offically supported API!\n     *\n     * TODO: Add tests (run a variation of themable-mixin.test.js where the components get created as LitElements)\n     * @protected\n     */\n    static finalizeStyles(styles) {\n      return (\n        getThemes(this.is)\n          // Get flattened styles array\n          .reduce((styles, theme) => [...styles, ...theme.styles], [])\n          .concat(styles)\n      );\n    }\n  };\n\nexport { themeRegistry as __themeRegistry };\n"],
  "mappings": "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",
  "names": []
}
