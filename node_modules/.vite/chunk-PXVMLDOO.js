import {
  FlattenedNodesObserver
} from "./chunk-WAPH3RCZ.js";
import {
  dedupingMixin
} from "./chunk-GN24F3WZ.js";

// node_modules/.pnpm/@vaadin/field-base@22.0.2/node_modules/@vaadin/field-base/src/labelled-input-controller.js
var LabelledInputController = class {
  constructor(input, label) {
    this.input = input;
    this.__preventDuplicateLabelClick = this.__preventDuplicateLabelClick.bind(this);
    if (label) {
      label.addEventListener("click", this.__preventDuplicateLabelClick);
      if (input) {
        label.setAttribute("for", input.id);
      }
    }
  }
  __preventDuplicateLabelClick() {
    const inputClickHandler = (e) => {
      e.stopImmediatePropagation();
      this.input.removeEventListener("click", inputClickHandler);
    };
    this.input.addEventListener("click", inputClickHandler);
  }
};

// node_modules/.pnpm/@vaadin/field-base@22.0.2/node_modules/@vaadin/field-base/src/delegate-state-mixin.js
var DelegateStateMixin = dedupingMixin((superclass) => class DelegateStateMixinClass extends superclass {
  static get properties() {
    return {
      stateTarget: {
        type: Object,
        observer: "_stateTargetChanged"
      }
    };
  }
  static get delegateAttrs() {
    return [];
  }
  static get delegateProps() {
    return [];
  }
  ready() {
    super.ready();
    this._createDelegateAttrsObserver();
    this._createDelegatePropsObserver();
  }
  _stateTargetChanged(target) {
    if (target) {
      this._ensureAttrsDelegated();
      this._ensurePropsDelegated();
    }
  }
  _createDelegateAttrsObserver() {
    this._createMethodObserver(`_delegateAttrsChanged(${this.constructor.delegateAttrs.join(", ")})`);
  }
  _createDelegatePropsObserver() {
    this._createMethodObserver(`_delegatePropsChanged(${this.constructor.delegateProps.join(", ")})`);
  }
  _ensureAttrsDelegated() {
    this.constructor.delegateAttrs.forEach((name) => {
      this._delegateAttribute(name, this[name]);
    });
  }
  _ensurePropsDelegated() {
    this.constructor.delegateProps.forEach((name) => {
      this._delegateProperty(name, this[name]);
    });
  }
  _delegateAttrsChanged(...values) {
    this.constructor.delegateAttrs.forEach((name, index) => {
      this._delegateAttribute(name, values[index]);
    });
  }
  _delegatePropsChanged(...values) {
    this.constructor.delegateProps.forEach((name, index) => {
      this._delegateProperty(name, values[index]);
    });
  }
  _delegateAttribute(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "invalid") {
      this._delegateAttribute("aria-invalid", value ? "true" : false);
    }
    if (typeof value === "boolean") {
      this.stateTarget.toggleAttribute(name, value);
    } else if (value) {
      this.stateTarget.setAttribute(name, value);
    } else {
      this.stateTarget.removeAttribute(name);
    }
  }
  _delegateProperty(name, value) {
    if (!this.stateTarget) {
      return;
    }
    this.stateTarget[name] = value;
  }
});

// node_modules/.pnpm/@vaadin/field-base@22.0.2/node_modules/@vaadin/field-base/src/input-mixin.js
var InputMixin = dedupingMixin((superclass) => class InputMixinClass extends superclass {
  static get properties() {
    return {
      inputElement: {
        type: Object,
        readOnly: true,
        observer: "_inputElementChanged"
      },
      type: {
        type: String,
        readOnly: true
      },
      value: {
        type: String,
        value: "",
        observer: "_valueChanged",
        notify: true
      }
    };
  }
  constructor() {
    super();
    this._boundOnInput = this._onInput.bind(this);
    this._boundOnChange = this._onChange.bind(this);
  }
  clear() {
    this.value = "";
  }
  _addInputListeners(input) {
    input.addEventListener("input", this._boundOnInput);
    input.addEventListener("change", this._boundOnChange);
  }
  _removeInputListeners(input) {
    input.removeEventListener("input", this._boundOnInput);
    input.removeEventListener("change", this._boundOnChange);
  }
  _forwardInputValue(value) {
    if (!this.inputElement) {
      return;
    }
    if (value != void 0) {
      this.inputElement.value = value;
    } else {
      this.inputElement.value = "";
    }
  }
  _inputElementChanged(input, oldInput) {
    if (input) {
      this._addInputListeners(input);
    } else if (oldInput) {
      this._removeInputListeners(oldInput);
    }
  }
  _onInput(event) {
    this.__userInput = event.isTrusted;
    this.value = event.target.value;
    this.__userInput = false;
  }
  _onChange(_event) {
  }
  _toggleHasValue(hasValue) {
    this.toggleAttribute("has-value", hasValue);
  }
  _valueChanged(newVal, oldVal) {
    this._toggleHasValue(newVal !== "" && newVal != null);
    if (newVal === "" && oldVal === void 0) {
      return;
    }
    if (this.__userInput) {
      return;
    }
    this._forwardInputValue(newVal);
  }
});

// node_modules/.pnpm/@vaadin/component-base@22.0.2/node_modules/@vaadin/component-base/src/slot-controller.js
var SlotController = class {
  constructor(host, slotName, slotFactory, slotInitializer) {
    this.host = host;
    this.slotName = slotName;
    this.slotFactory = slotFactory;
    this.slotInitializer = slotInitializer;
  }
  hostConnected() {
    if (!this.initialized) {
      const { host, slotName, slotFactory, slotInitializer } = this;
      const slotted = this.getSlotChild();
      if (!slotted) {
        if (slotFactory) {
          const slotContent = slotFactory(host);
          if (slotContent instanceof Element) {
            if (slotName !== "") {
              slotContent.setAttribute("slot", slotName);
            }
            host.appendChild(slotContent);
            this.node = slotContent;
            this.defaultNode = slotContent;
          }
        }
      } else {
        this.node = slotted;
      }
      if (slotInitializer) {
        slotInitializer(host, this.node);
      }
      this.observe();
      this.initialized = true;
    }
  }
  getSlotChild() {
    const { slotName } = this;
    return Array.from(this.host.childNodes).find((node) => {
      return node.nodeType === Node.ELEMENT_NODE && node.slot === slotName || node.nodeType === Node.TEXT_NODE && node.textContent.trim() && slotName === "";
    });
  }
  initCustomNode(_node) {
  }
  teardownNode(_node) {
  }
  observe() {
    const { slotName } = this;
    const selector = slotName === "" ? "slot:not([name])" : `slot[name=${slotName}]`;
    const slot = this.host.shadowRoot.querySelector(selector);
    this.__slotObserver = new FlattenedNodesObserver(slot, (info) => {
      const current = this.node;
      const newNode = info.addedNodes.find((node) => node !== current);
      if (info.removedNodes.length) {
        info.removedNodes.forEach((node) => {
          this.teardownNode(node);
        });
      }
      if (newNode) {
        if (current && current.isConnected) {
          this.host.removeChild(current);
        }
        this.node = newNode;
        if (newNode !== this.defaultNode) {
          this.initCustomNode(newNode);
        }
      }
    });
  }
};

export {
  DelegateStateMixin,
  InputMixin,
  SlotController,
  LabelledInputController
};
/**
 * @license
 * Copyright (c) 2021 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-PXVMLDOO.js.map
