import {
  pathFromUrl,
  resolveCss,
  resolveUrl,
  strictTemplatePolicy
} from "./chunk-FHJNRKKV.js";

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/elements/dom-module.js
var modules = {};
var lcModules = {};
function setModule(id, module) {
  modules[id] = lcModules[id.toLowerCase()] = module;
}
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}
function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector("style")) {
    console.warn("dom-module %s has style outside template", inst.id);
  }
}
var DomModule = class extends HTMLElement {
  static get observedAttributes() {
    return ["id"];
  }
  static import(id, selector) {
    if (id) {
      let m = findModule(id);
      if (m && selector) {
        return m.querySelector(selector);
      }
      return m;
    }
    return null;
  }
  attributeChangedCallback(name, old, value, namespace) {
    if (old !== value) {
      this.register();
    }
  }
  get assetpath() {
    if (!this.__assetpath) {
      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = resolveUrl(this.getAttribute("assetpath") || "", owner.baseURI);
      this.__assetpath = pathFromUrl(url);
    }
    return this.__assetpath;
  }
  register(id) {
    id = id || this.id;
    if (id) {
      if (strictTemplatePolicy && findModule(id) !== void 0) {
        setModule(id, null);
        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);
      }
      this.id = id;
      setModule(id, this);
      styleOutsideTemplateCheck(this);
    }
  }
};
DomModule.prototype["modules"] = modules;
customElements.define("dom-module", DomModule);

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/utils/style-gather.js
var MODULE_STYLE_LINK_SELECTOR = "link[rel=import][type~=css]";
var INCLUDE_ATTR = "include";
var SHADY_UNSCOPED_ATTR = "shady-unscoped";
function importModule(moduleId) {
  return DomModule.import(moduleId);
}
function styleForImport(importDoc) {
  let container = importDoc.body ? importDoc.body : importDoc;
  const importCss = resolveCss(container.textContent, importDoc.baseURI);
  const style = document.createElement("style");
  style.textContent = importCss;
  return style;
}
function stylesFromModules(moduleIds) {
  const modules2 = moduleIds.trim().split(/\s+/);
  const styles = [];
  for (let i = 0; i < modules2.length; i++) {
    styles.push(...stylesFromModule(modules2[i]));
  }
  return styles;
}
function stylesFromModule(moduleId) {
  const m = importModule(moduleId);
  if (!m) {
    console.warn("Could not find style data in module named", moduleId);
    return [];
  }
  if (m._styles === void 0) {
    const styles = [];
    styles.push(..._stylesFromModuleImports(m));
    const template = m.querySelector("template");
    if (template) {
      styles.push(...stylesFromTemplate(template, m.assetpath));
    }
    m._styles = styles;
  }
  return m._styles;
}
function stylesFromTemplate(template, baseURI) {
  if (!template._styles) {
    const styles = [];
    const e$ = template.content.querySelectorAll("style");
    for (let i = 0; i < e$.length; i++) {
      let e = e$[i];
      let include = e.getAttribute(INCLUDE_ATTR);
      if (include) {
        styles.push(...stylesFromModules(include).filter(function(item, index, self) {
          return self.indexOf(item) === index;
        }));
      }
      if (baseURI) {
        e.textContent = resolveCss(e.textContent, baseURI);
      }
      styles.push(e);
    }
    template._styles = styles;
  }
  return template._styles;
}
function stylesFromModuleImports(moduleId) {
  let m = importModule(moduleId);
  return m ? _stylesFromModuleImports(m) : [];
}
function _stylesFromModuleImports(module) {
  const styles = [];
  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (let i = 0; i < p$.length; i++) {
    let p = p$[i];
    if (p.import) {
      const importDoc = p.import;
      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);
      if (unscoped && !importDoc._unscopedStyle) {
        const style = styleForImport(importDoc);
        style.setAttribute(SHADY_UNSCOPED_ATTR, "");
        importDoc._unscopedStyle = style;
      } else if (!importDoc._style) {
        importDoc._style = styleForImport(importDoc);
      }
      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
    }
  }
  return styles;
}
function cssFromModules(moduleIds) {
  let modules2 = moduleIds.trim().split(/\s+/);
  let cssText = "";
  for (let i = 0; i < modules2.length; i++) {
    cssText += cssFromModule(modules2[i]);
  }
  return cssText;
}
function cssFromModule(moduleId) {
  let m = importModule(moduleId);
  if (m && m._cssText === void 0) {
    let cssText = _cssFromModuleImports(m);
    let t = m.querySelector("template");
    if (t) {
      cssText += cssFromTemplate(t, m.assetpath);
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn("Could not find style data in module named", moduleId);
  }
  return m && m._cssText || "";
}
function cssFromTemplate(template, baseURI) {
  let cssText = "";
  const e$ = stylesFromTemplate(template, baseURI);
  for (let i = 0; i < e$.length; i++) {
    let e = e$[i];
    if (e.parentNode) {
      e.parentNode.removeChild(e);
    }
    cssText += e.textContent;
  }
  return cssText;
}
function _cssFromModuleImports(module) {
  let cssText = "";
  let styles = _stylesFromModuleImports(module);
  for (let i = 0; i < styles.length; i++) {
    cssText += styles[i].textContent;
  }
  return cssText;
}

export {
  DomModule,
  stylesFromTemplate,
  stylesFromModuleImports,
  cssFromModules
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
//# sourceMappingURL=chunk-PN57JW3E.js.map
