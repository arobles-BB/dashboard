import {
  Debouncer,
  timeOut
} from "./chunk-MQRWSCDX.js";

// node_modules/.pnpm/@vaadin/grid@22.0.2/node_modules/@vaadin/grid/src/vaadin-grid-data-provider-mixin.js
var ItemCache = class ItemCache2 {
  constructor(grid, parentCache, parentItem) {
    this.grid = grid;
    this.parentCache = parentCache;
    this.parentItem = parentItem;
    this.itemCaches = {};
    this.items = {};
    this.effectiveSize = 0;
    this.size = 0;
    this.pendingRequests = {};
  }
  isLoading() {
    return Boolean(Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter((index) => {
      return this.itemCaches[index].isLoading();
    })[0]);
  }
  getItemForIndex(index) {
    const { cache, scaledIndex } = this.getCacheAndIndex(index);
    return cache.items[scaledIndex];
  }
  updateSize() {
    this.effectiveSize = !this.parentItem || this.grid._isExpanded(this.parentItem) ? this.size + Object.keys(this.itemCaches).reduce((prev, curr) => {
      const subCache = this.itemCaches[curr];
      subCache.updateSize();
      return prev + subCache.effectiveSize;
    }, 0) : 0;
  }
  ensureSubCacheForScaledIndex(scaledIndex) {
    if (!this.itemCaches[scaledIndex]) {
      const subCache = new ItemCache2(this.grid, this, this.items[scaledIndex]);
      this.itemCaches[scaledIndex] = subCache;
      this.grid._loadPage(0, subCache);
    }
  }
  getCacheAndIndex(index) {
    let thisLevelIndex = index;
    const keys = Object.keys(this.itemCaches);
    for (let i = 0; i < keys.length; i++) {
      const expandedIndex = Number(keys[i]);
      const subCache = this.itemCaches[expandedIndex];
      if (thisLevelIndex <= expandedIndex) {
        return { cache: this, scaledIndex: thisLevelIndex };
      } else if (thisLevelIndex <= expandedIndex + subCache.effectiveSize) {
        return subCache.getCacheAndIndex(thisLevelIndex - expandedIndex - 1);
      }
      thisLevelIndex -= subCache.effectiveSize;
    }
    return { cache: this, scaledIndex: thisLevelIndex };
  }
};
var DataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      size: {
        type: Number,
        notify: true
      },
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged"
      },
      dataProvider: {
        type: Object,
        notify: true,
        observer: "_dataProviderChanged"
      },
      loading: {
        type: Boolean,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },
      _cache: {
        type: Object,
        value: function() {
          const cache = new ItemCache(this);
          return cache;
        }
      },
      _hasData: {
        type: Boolean,
        value: false
      },
      itemIdPath: {
        type: String,
        value: null
      },
      expandedItems: {
        type: Object,
        notify: true,
        value: () => []
      },
      __expandedKeys: {
        type: Object,
        value: () => new Set()
      }
    };
  }
  static get observers() {
    return ["_sizeChanged(size)", "_itemIdPathChanged(itemIdPath)", "_expandedItemsChanged(expandedItems.*)"];
  }
  _sizeChanged(size) {
    const delta = size - this._cache.size;
    this._cache.size += delta;
    this._cache.effectiveSize += delta;
    this._effectiveSize = this._cache.effectiveSize;
  }
  _getItem(index, el) {
    if (index >= this._effectiveSize) {
      return;
    }
    el.index = index;
    const { cache, scaledIndex } = this._cache.getCacheAndIndex(index);
    const item = cache.items[scaledIndex];
    if (item) {
      el.toggleAttribute("loading", false);
      this._updateItem(el, item);
      if (this._isExpanded(item)) {
        cache.ensureSubCacheForScaledIndex(scaledIndex);
      }
    } else {
      el.toggleAttribute("loading", true);
      this._loadPage(this._getPageForIndex(scaledIndex), cache);
    }
  }
  getItemId(item) {
    return this.itemIdPath ? this.get(this.itemIdPath, item) : item;
  }
  _isExpanded(item) {
    return this.__expandedKeys.has(this.getItemId(item));
  }
  _expandedItemsChanged() {
    this.__cacheExpandedKeys();
    this._cache.updateSize();
    this._effectiveSize = this._cache.effectiveSize;
    this.__updateVisibleRows();
  }
  _itemIdPathChanged() {
    this.__cacheExpandedKeys();
  }
  __cacheExpandedKeys() {
    if (this.expandedItems) {
      this.__expandedKeys = new Set();
      this.expandedItems.forEach((item) => {
        this.__expandedKeys.add(this.getItemId(item));
      });
    }
  }
  expandItem(item) {
    if (!this._isExpanded(item)) {
      this.expandedItems = [...this.expandedItems, item];
    }
  }
  collapseItem(item) {
    if (this._isExpanded(item)) {
      this.expandedItems = this.expandedItems.filter((i) => !this._itemsEqual(i, item));
    }
  }
  _getIndexLevel(index) {
    let { cache } = this._cache.getCacheAndIndex(index);
    let level = 0;
    while (cache.parentCache) {
      cache = cache.parentCache;
      level++;
    }
    return level;
  }
  _loadPage(page, cache) {
    if (!cache.pendingRequests[page] && this.dataProvider) {
      this._setLoading(true);
      cache.pendingRequests[page] = true;
      const params = {
        page,
        pageSize: this.pageSize,
        sortOrders: this._mapSorters(),
        filters: this._mapFilters(),
        parentItem: cache.parentItem
      };
      this.dataProvider(params, (items, size) => {
        if (size !== void 0) {
          cache.size = size;
        } else {
          if (params.parentItem) {
            cache.size = items.length;
          }
        }
        const currentItems = Array.from(this.$.items.children).map((row) => row._item);
        items.forEach((item, itemsIndex) => {
          const itemIndex = page * this.pageSize + itemsIndex;
          cache.items[itemIndex] = item;
          if (this._isExpanded(item) && currentItems.indexOf(item) > -1) {
            cache.ensureSubCacheForScaledIndex(itemIndex);
          }
        });
        this._hasData = true;
        delete cache.pendingRequests[page];
        this._debouncerApplyCachedData = Debouncer.debounce(this._debouncerApplyCachedData, timeOut.after(0), () => {
          this._setLoading(false);
          this._cache.updateSize();
          this._effectiveSize = this._cache.effectiveSize;
          Array.from(this.$.items.children).filter((row) => !row.hidden).forEach((row) => {
            const cachedItem = this._cache.getItemForIndex(row.index);
            if (cachedItem) {
              this._getItem(row.index, row);
            }
          });
          this.__scrollToPendingIndex();
        });
        if (!this._cache.isLoading()) {
          this._debouncerApplyCachedData.flush();
        }
        this.__itemsReceived();
      });
    }
  }
  _getPageForIndex(index) {
    return Math.floor(index / this.pageSize);
  }
  clearCache() {
    this._cache = new ItemCache(this);
    this._cache.size = this.size || 0;
    this._cache.updateSize();
    this._hasData = false;
    this.__updateVisibleRows();
    if (!this._effectiveSize) {
      this._loadPage(0, this._cache);
    }
  }
  _pageSizeChanged(pageSize, oldPageSize) {
    if (oldPageSize !== void 0 && pageSize !== oldPageSize) {
      this.clearCache();
    }
  }
  _checkSize() {
    if (this.size === void 0 && this._effectiveSize === 0) {
      console.warn("The <vaadin-grid> needs the total number of items in order to display rows. Set the total number of items to the `size` property, or provide the total number of items in the second argument of the `dataProvider`\u2019s `callback` call.");
    }
  }
  _dataProviderChanged(dataProvider, oldDataProvider) {
    if (oldDataProvider !== void 0) {
      this.clearCache();
    }
    this._ensureFirstPageLoaded();
    this._debouncerCheckSize = Debouncer.debounce(this._debouncerCheckSize, timeOut.after(2e3), this._checkSize.bind(this));
  }
  _ensureFirstPageLoaded() {
    if (!this._hasData) {
      this._loadPage(0, this._cache);
    }
  }
  _itemsEqual(item1, item2) {
    return this.getItemId(item1) === this.getItemId(item2);
  }
  _getItemIndexInArray(item, array) {
    let result = -1;
    array.forEach((i, idx) => {
      if (this._itemsEqual(i, item)) {
        result = idx;
      }
    });
    return result;
  }
  scrollToIndex(index) {
    super.scrollToIndex(index);
    if (!isNaN(index) && (this._cache.isLoading() || !this.clientHeight)) {
      this.__pendingScrollToIndex = index;
    }
  }
  __scrollToPendingIndex() {
    if (this.__pendingScrollToIndex && this.$.items.children.length) {
      const index = this.__pendingScrollToIndex;
      delete this.__pendingScrollToIndex;
      this.scrollToIndex(index);
    }
  }
};

export {
  ItemCache,
  DataProviderMixin
};
/**
 * @license
 * Copyright (c) 2021 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-WEU5DNUF.js.map
