import {
  dedupingMixin
} from "./chunk-GN24F3WZ.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-GWBPVOL2.js";

// node_modules/.pnpm/@vaadin/component-base@22.0.2/node_modules/@vaadin/component-base/src/controller-mixin.js
var ControllerMixin = dedupingMixin((superClass) => class ControllerMixinClass extends superClass {
  constructor() {
    super();
    this.__controllers = new Set();
  }
  connectedCallback() {
    super.connectedCallback();
    this.__controllers.forEach((c) => {
      c.hostConnected && c.hostConnected();
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__controllers.forEach((c) => {
      c.hostDisconnected && c.hostDisconnected();
    });
  }
  addController(controller) {
    this.__controllers.add(controller);
    if (this.$ !== void 0 && this.isConnected && controller.hostConnected) {
      controller.hostConnected();
    }
  }
  removeController(controller) {
    this.__controllers.delete(controller);
  }
});

// node_modules/.pnpm/@vaadin/component-base@22.0.2/node_modules/@vaadin/component-base/src/slot-mixin.js
var SlotMixin = dedupingMixin((superclass) => class SlotMixinClass extends superclass {
  get slots() {
    return {};
  }
  ready() {
    super.ready();
    this._connectSlotMixin();
  }
  _connectSlotMixin() {
    Object.keys(this.slots).forEach((slotName) => {
      const hasContent = this._getDirectSlotChild(slotName) !== void 0;
      if (!hasContent) {
        const slotFactory = this.slots[slotName];
        const slotContent = slotFactory();
        if (slotContent instanceof Element) {
          slotContent.setAttribute("slot", slotName);
          this.appendChild(slotContent);
        }
      }
    });
  }
  _getDirectSlotChild(slotName) {
    return Array.from(this.children).find((el) => el.slot === slotName);
  }
});

// node_modules/.pnpm/@vaadin/field-base@22.0.2/node_modules/@vaadin/field-base/src/label-mixin.js
var LabelMixin = dedupingMixin((superclass) => class LabelMixinClass extends SlotMixin(superclass) {
  static get properties() {
    return {
      label: {
        type: String,
        observer: "_labelChanged"
      }
    };
  }
  get slots() {
    return __spreadProps(__spreadValues({}, super.slots), {
      label: () => {
        const label = document.createElement("label");
        label.textContent = this.label;
        return label;
      }
    });
  }
  get _labelNode() {
    return this._getDirectSlotChild("label");
  }
  constructor() {
    super();
    const uniqueId = LabelMixinClass._uniqueLabelId = 1 + LabelMixinClass._uniqueLabelId || 0;
    this._labelId = `label-${this.localName}-${uniqueId}`;
    this.__labelNodeObserver = new MutationObserver(() => {
      this._toggleHasLabelAttribute();
    });
  }
  ready() {
    super.ready();
    if (this._labelNode) {
      this._labelNode.id = this._labelId;
      this._toggleHasLabelAttribute();
      this.__labelNodeObserver.observe(this._labelNode, { childList: true, subtree: true, characterData: true });
    }
  }
  _labelChanged(label) {
    if (this._labelNode) {
      this._labelNode.textContent = label;
      this._toggleHasLabelAttribute();
    }
  }
  _toggleHasLabelAttribute() {
    if (this._labelNode) {
      const hasLabel = this._labelNode.children.length > 0 || this._labelNode.textContent.trim() !== "";
      this.toggleAttribute("has-label", hasLabel);
    }
  }
});

export {
  ControllerMixin,
  SlotMixin,
  LabelMixin
};
/**
 * @license
 * Copyright (c) 2021 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-7ORJFUKA.js.map
