{
  "version": 3,
  "sources": ["../.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/elements/dom-if.js"],
  "sourcesContent": ["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\n\nimport { templatize } from '../utils/templatize.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\n\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\nexport class DomIf extends PolymerElement {\n\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() { return 'dom-if'; }\n\n  static get template() { return null; }\n\n  static get properties() {\n\n    return {\n\n      /**\n       * Fired whenever DOM is added or removed/hidden by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n\n      /**\n       * A boolean indicating whether this template should stamp.\n       */\n      if: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n\n      /**\n       * When true, elements will be removed from DOM and discarded when `if`\n       * becomes false and re-created and added back to the DOM when `if`\n       * becomes true.  By default, stamped elements will be hidden but left\n       * in the DOM when `if` becomes false, which is generally results\n       * in better performance.\n       */\n      restamp: {\n        type: Boolean,\n        observer: '__debounceRender'\n      }\n\n    };\n\n  }\n\n  constructor() {\n    super();\n    this.__renderDebouncer = null;\n    this.__invalidProps = null;\n    this.__instance = null;\n    this._lastIf = false;\n    this.__ctor = null;\n    this.__hideTemplateChildren__ = false;\n  }\n\n  __debounceRender() {\n    // Render is async for 2 reasons:\n    // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n    //    same turn. This was more common in 1.x where a compound computed\n    //    property could result in the result changing multiple times, but is\n    //    mitigated to a large extent by batched property processing in 2.x.\n    // 2. To avoid double object propagation when a bag including values bound\n    //    to the `if` property as well as one or more hostProps could enqueue\n    //    the <dom-if> to flush before the <template>'s host property\n    //    forwarding. In that scenario creating an instance would result in\n    //    the host props being set once, and then the enqueued changes on the\n    //    template would set properties a second time, potentially causing an\n    //    object to be set to an instance more than once.  Creating the\n    //    instance async from flushing data ensures this doesn't happen. If\n    //    we wanted a sync option in the future, simply having <dom-if> flush\n    //    (or clear) its template's pending host properties before creating\n    //    the instance would also avoid the problem.\n    this.__renderDebouncer = Debouncer.debounce(\n          this.__renderDebouncer\n        , microTask\n        , () => this.__render());\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    const parent = wrap(this).parentNode;\n    if (!parent || (parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&\n        !wrap(parent).host)) {\n      this.__teardownInstance();\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.style.display = 'none';\n    if (this.if) {\n      this.__debounceRender();\n    }\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   * @return {void}\n   */\n  render() {\n    flush();\n  }\n\n  __render() {\n    if (this.if) {\n      if (!this.__ensureInstance()) {\n        // No template found yet\n        return;\n      }\n      this._showHideChildren();\n    } else if (this.restamp) {\n      this.__teardownInstance();\n    }\n    if (!this.restamp && this.__instance) {\n      this._showHideChildren();\n    }\n    if (this.if != this._lastIf) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      this._lastIf = this.if;\n    }\n  }\n\n  __ensureInstance() {\n    let parentNode = wrap(this).parentNode;\n    // Guard against element being detached while render was queued\n    if (parentNode) {\n      if (!this.__ctor) {\n        let template = /** @type {HTMLTemplateElement} */(wrap(this).querySelector('template'));\n        if (!template) {\n          // Wait until childList changes and template should be there by then\n          let observer = new MutationObserver(() => {\n            if (wrap(this).querySelector('template')) {\n              observer.disconnect();\n              this.__render();\n            } else {\n              throw new Error('dom-if requires a <template> child');\n            }\n          });\n          observer.observe(this, {childList: true});\n          return false;\n        }\n        this.__ctor = templatize(template, this, {\n          // dom-if templatizer instances require `mutable: true`, as\n          // `__syncHostProperties` relies on that behavior to sync objects\n          mutableData: true,\n          /**\n           * @param {string} prop Property to forward\n           * @param {*} value Value of property\n           * @this {DomIf}\n           */\n          forwardHostProp: function(prop, value) {\n            if (this.__instance) {\n              if (this.if) {\n                this.__instance.forwardHostProp(prop, value);\n              } else {\n                // If we have an instance but are squelching host property\n                // forwarding due to if being false, note the invalidated\n                // properties so `__syncHostProperties` can sync them the next\n                // time `if` becomes true\n                this.__invalidProps = this.__invalidProps || Object.create(null);\n                this.__invalidProps[root(prop)] = true;\n              }\n            }\n          }\n        });\n      }\n      if (!this.__instance) {\n        this.__instance = new this.__ctor();\n        wrap(parentNode).insertBefore(this.__instance.root, this);\n      } else {\n        this.__syncHostProperties();\n        let c$ = this.__instance.children;\n        if (c$ && c$.length) {\n          // Detect case where dom-if was re-attached in new position\n          let lastChild = wrap(this).previousSibling;\n          if (lastChild !== c$[c$.length-1]) {\n            for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n              wrap(parentNode).insertBefore(n, this);\n            }\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  __syncHostProperties() {\n    let props = this.__invalidProps;\n    if (props) {\n      for (let prop in props) {\n        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n      }\n      this.__invalidProps = null;\n      this.__instance._flushProperties();\n    }\n  }\n\n  __teardownInstance() {\n    if (this.__instance) {\n      let c$ = this.__instance.children;\n      if (c$ && c$.length) {\n        // use first child parent, for case when dom-if may have been detached\n        let parent = wrap(c$[0]).parentNode;\n        // Instance children may be disconnected from parents when dom-if\n        // detaches if a tree was innerHTML'ed\n        if (parent) {\n          parent = wrap(parent);\n          for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n            parent.removeChild(n);\n          }\n        }\n      }\n      this.__instance = null;\n      this.__invalidProps = null;\n    }\n  }\n\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @return {void}\n   * @protected\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    let hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance) {\n      this.__instance._showHideChildren(hidden);\n    }\n  }\n\n}\n\ncustomElements.define(DomIf.is, DomIf);\n"],
  "mappings": "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",
  "names": []
}
