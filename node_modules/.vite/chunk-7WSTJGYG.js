import {
  isIOS
} from "./chunk-5YJRHVYL.js";
import {
  templatize
} from "./chunk-GLSLTN6S.js";
import {
  afterNextRender
} from "./chunk-5SUV3F4B.js";
import {
  FlattenedNodesObserver
} from "./chunk-WAPH3RCZ.js";
import {
  ThemableMixin
} from "./chunk-FZIWHSOX.js";
import {
  DirMixin
} from "./chunk-JZ7X4XI4.js";
import {
  PolymerElement
} from "./chunk-RZW6ORFJ.js";
import {
  html
} from "./chunk-5VJMXRGB.js";

// node_modules/.pnpm/@vaadin/vaadin-overlay@22.0.2/node_modules/@vaadin/vaadin-overlay/src/vaadin-focusables-helper.js
var FocusablesHelper = class {
  static getTabbableNodes(node) {
    const result = [];
    const needsSortByTabIndex = this._collectTabbableNodes(node, result);
    if (needsSortByTabIndex) {
      return this._sortByTabIndex(result);
    }
    return result;
  }
  static isFocusable(element) {
    if (element.matches("input, select, textarea, button, object")) {
      return element.matches(":not([disabled])");
    }
    return element.matches("a[href], area[href], iframe, [tabindex], [contentEditable]");
  }
  static isTabbable(element) {
    return this.isFocusable(element) && element.matches(':not([tabindex="-1"])') && this._isVisible(element);
  }
  static _normalizedTabIndex(element) {
    if (this.isFocusable(element)) {
      const tabIndex = element.getAttribute("tabindex") || 0;
      return Number(tabIndex);
    }
    return -1;
  }
  static _collectTabbableNodes(node, result) {
    if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {
      return false;
    }
    const element = node;
    const tabIndex = this._normalizedTabIndex(element);
    let needsSort = tabIndex > 0;
    if (tabIndex >= 0) {
      result.push(element);
    }
    let children;
    if (element.localName === "slot") {
      children = element.assignedNodes({ flatten: true });
    } else {
      children = (element.shadowRoot || element).children;
    }
    if (children) {
      for (let i = 0; i < children.length; i++) {
        needsSort = this._collectTabbableNodes(children[i], result) || needsSort;
      }
    }
    return needsSort;
  }
  static _isVisible(element) {
    let style = element.style;
    if (style.visibility !== "hidden" && style.display !== "none") {
      style = window.getComputedStyle(element);
      return style.visibility !== "hidden" && style.display !== "none";
    }
    return false;
  }
  static _sortByTabIndex(tabbables) {
    const len = tabbables.length;
    if (len < 2) {
      return tabbables;
    }
    const pivot = Math.ceil(len / 2);
    const left = this._sortByTabIndex(tabbables.slice(0, pivot));
    const right = this._sortByTabIndex(tabbables.slice(pivot));
    return this._mergeSortByTabIndex(left, right);
  }
  static _mergeSortByTabIndex(left, right) {
    const result = [];
    while (left.length > 0 && right.length > 0) {
      if (this._hasLowerTabOrder(left[0], right[0])) {
        result.push(right.shift());
      } else {
        result.push(left.shift());
      }
    }
    return result.concat(left, right);
  }
  static _hasLowerTabOrder(a, b) {
    const ati = Math.max(a.tabIndex, 0);
    const bti = Math.max(b.tabIndex, 0);
    return ati === 0 || bti === 0 ? bti > ati : ati > bti;
  }
};

// node_modules/.pnpm/@vaadin/vaadin-overlay@22.0.2/node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay.js
var OverlayElement = class extends ThemableMixin(DirMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          z-index: 200;
          position: fixed;

          /* Despite of what the names say, <vaadin-overlay> is just a container
          for position/sizing/alignment. The actual overlay is the overlay part. */

          /* Default position constraints: the entire viewport. Note: themes can
          override this to introduce gaps between the overlay and the viewport. */
          top: 0;
          right: 0;
          bottom: var(--vaadin-overlay-viewport-bottom);
          left: 0;

          /* Use flexbox alignment for the overlay part. */
          display: flex;
          flex-direction: column; /* makes dropdowns sizing easier */
          /* Align to center by default. */
          align-items: center;
          justify-content: center;

          /* Allow centering when max-width/max-height applies. */
          margin: auto;

          /* The host is not clickable, only the overlay part is. */
          pointer-events: none;

          /* Remove tap highlight on touch devices. */
          -webkit-tap-highlight-color: transparent;

          /* CSS API for host */
          --vaadin-overlay-viewport-bottom: 0;
        }

        :host([hidden]),
        :host(:not([opened]):not([closing])) {
          display: none !important;
        }

        [part='overlay'] {
          -webkit-overflow-scrolling: touch;
          overflow: auto;
          pointer-events: auto;

          /* Prevent overflowing the host in MSIE 11 */
          max-width: 100%;
          box-sizing: border-box;

          -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */
        }

        [part='backdrop'] {
          z-index: -1;
          content: '';
          background: rgba(0, 0, 0, 0.5);
          position: fixed;
          top: 0;
          left: 0;
          bottom: 0;
          right: 0;
          pointer-events: auto;
        }
      </style>

      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-overlay";
  }
  static get properties() {
    return {
      opened: {
        type: Boolean,
        notify: true,
        observer: "_openedChanged",
        reflectToAttribute: true
      },
      owner: Element,
      renderer: Function,
      template: {
        type: Object,
        notify: true
      },
      instanceProps: {
        type: Object
      },
      content: {
        type: Object,
        notify: true
      },
      withBackdrop: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      model: Object,
      modeless: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_modelessChanged"
      },
      hidden: {
        type: Boolean,
        reflectToAttribute: true,
        observer: "_hiddenChanged"
      },
      focusTrap: {
        type: Boolean,
        value: false
      },
      restoreFocusOnClose: {
        type: Boolean,
        value: false
      },
      _mouseDownInside: {
        type: Boolean
      },
      _mouseUpInside: {
        type: Boolean
      },
      _instance: {
        type: Object
      },
      _originalContentPart: Object,
      _contentNodes: Array,
      _oldOwner: Element,
      _oldModel: Object,
      _oldTemplate: Object,
      _oldInstanceProps: Object,
      _oldRenderer: Object,
      _oldOpened: Boolean
    };
  }
  static get observers() {
    return ["_templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened)"];
  }
  constructor() {
    super();
    this._boundMouseDownListener = this._mouseDownListener.bind(this);
    this._boundMouseUpListener = this._mouseUpListener.bind(this);
    this._boundOutsideClickListener = this._outsideClickListener.bind(this);
    this._boundKeydownListener = this._keydownListener.bind(this);
    this._observer = new FlattenedNodesObserver(this, (info) => {
      this._setTemplateFromNodes(info.addedNodes);
    });
    this._boundIronOverlayCanceledListener = this._ironOverlayCanceled.bind(this);
    if (isIOS) {
      this._boundIosResizeListener = () => this._detectIosNavbar();
    }
  }
  ready() {
    super.ready();
    this._observer.flush();
    this.addEventListener("click", () => {
    });
    this.$.backdrop.addEventListener("click", () => {
    });
  }
  _detectIosNavbar() {
    if (!this.opened) {
      return;
    }
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", clientHeight - innerHeight + "px");
    } else {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", "0");
    }
  }
  _setTemplateFromNodes(nodes) {
    this.template = nodes.filter((node) => node.localName && node.localName === "template")[0] || this.template;
  }
  close(sourceEvent) {
    var evt = new CustomEvent("vaadin-overlay-close", {
      bubbles: true,
      cancelable: true,
      detail: { sourceEvent }
    });
    this.dispatchEvent(evt);
    if (!evt.defaultPrevented) {
      this.opened = false;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (this._boundIosResizeListener) {
      this._detectIosNavbar();
      window.addEventListener("resize", this._boundIosResizeListener);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._boundIosResizeListener) {
      window.removeEventListener("resize", this._boundIosResizeListener);
    }
  }
  requestContentUpdate() {
    if (this.renderer) {
      this.renderer.call(this.owner, this.content, this.owner, this.model);
    }
  }
  _ironOverlayCanceled(event) {
    event.preventDefault();
  }
  _mouseDownListener(event) {
    this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  _mouseUpListener(event) {
    this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  _outsideClickListener(event) {
    if (event.composedPath().indexOf(this.$.overlay) !== -1 || this._mouseDownInside || this._mouseUpInside) {
      this._mouseDownInside = false;
      this._mouseUpInside = false;
      return;
    }
    if (!this._last) {
      return;
    }
    const evt = new CustomEvent("vaadin-overlay-outside-click", {
      bubbles: true,
      cancelable: true,
      detail: { sourceEvent: event }
    });
    this.dispatchEvent(evt);
    if (this.opened && !evt.defaultPrevented) {
      this.close(event);
    }
  }
  _keydownListener(event) {
    if (!this._last) {
      return;
    }
    if (event.key === "Tab" && this.focusTrap && !event.defaultPrevented) {
      this._cycleTab(event.shiftKey ? -1 : 1);
      event.preventDefault();
    } else if (event.key === "Escape" || event.key === "Esc") {
      const evt = new CustomEvent("vaadin-overlay-escape-press", {
        bubbles: true,
        cancelable: true,
        detail: { sourceEvent: event }
      });
      this.dispatchEvent(evt);
      if (this.opened && !evt.defaultPrevented) {
        this.close(event);
      }
    }
  }
  _ensureTemplatized() {
    this._setTemplateFromNodes(Array.from(this.children));
  }
  _openedChanged(opened, wasOpened) {
    if (!this._instance) {
      this._ensureTemplatized();
    }
    if (opened) {
      this.__restoreFocusNode = this._getActiveElement();
      this._animatedOpening();
      afterNextRender(this, () => {
        if (this.focusTrap && !this.contains(document.activeElement)) {
          this._cycleTab(0, 0);
        }
        const evt = new CustomEvent("vaadin-overlay-open", { bubbles: true });
        this.dispatchEvent(evt);
      });
      if (!this.modeless) {
        this._addGlobalListeners();
      }
    } else if (wasOpened) {
      this._animatedClosing();
      if (!this.modeless) {
        this._removeGlobalListeners();
      }
    }
  }
  _hiddenChanged(hidden) {
    if (hidden && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
  }
  _shouldAnimate() {
    const name = getComputedStyle(this).getPropertyValue("animation-name");
    const hidden = getComputedStyle(this).getPropertyValue("display") === "none";
    return !hidden && name && name != "none";
  }
  _enqueueAnimation(type, callback) {
    const handler = `__${type}Handler`;
    const listener = (event) => {
      if (event && event.target !== this) {
        return;
      }
      callback();
      this.removeEventListener("animationend", listener);
      delete this[handler];
    };
    this[handler] = listener;
    this.addEventListener("animationend", listener);
  }
  _flushAnimation(type) {
    const handler = `__${type}Handler`;
    if (typeof this[handler] === "function") {
      this[handler]();
    }
  }
  _animatedOpening() {
    if (this.parentNode === document.body && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
    this._attachOverlay();
    if (!this.modeless) {
      this._enterModalState();
    }
    this.setAttribute("opening", "");
    const finishOpening = () => {
      document.addEventListener("iron-overlay-canceled", this._boundIronOverlayCanceledListener);
      this.removeAttribute("opening");
    };
    if (this._shouldAnimate()) {
      this._enqueueAnimation("opening", finishOpening);
    } else {
      finishOpening();
    }
  }
  _attachOverlay() {
    this._placeholder = document.createComment("vaadin-overlay-placeholder");
    this.parentNode.insertBefore(this._placeholder, this);
    document.body.appendChild(this);
    this.bringToFront();
  }
  _animatedClosing() {
    if (this.hasAttribute("opening")) {
      this._flushAnimation("opening");
    }
    if (this._placeholder) {
      this._exitModalState();
      if (this.restoreFocusOnClose && this.__restoreFocusNode) {
        const activeElement = this._getActiveElement();
        if (activeElement === document.body || this._deepContains(activeElement)) {
          this.__restoreFocusNode.focus();
        }
        this.__restoreFocusNode = null;
      }
      this.setAttribute("closing", "");
      const finishClosing = () => {
        document.removeEventListener("iron-overlay-canceled", this._boundIronOverlayCanceledListener);
        this._detachOverlay();
        this.shadowRoot.querySelector('[part="overlay"]').style.removeProperty("pointer-events");
        this.removeAttribute("closing");
      };
      if (this._shouldAnimate()) {
        this._enqueueAnimation("closing", finishClosing);
      } else {
        finishClosing();
      }
    }
  }
  _detachOverlay() {
    this._placeholder.parentNode.insertBefore(this, this._placeholder);
    this._placeholder.parentNode.removeChild(this._placeholder);
  }
  static get __attachedInstances() {
    return Array.from(document.body.children).filter((el) => el instanceof OverlayElement && !el.hasAttribute("closing")).sort((a, b) => a.__zIndex - b.__zIndex || 0);
  }
  get _last() {
    return this === OverlayElement.__attachedInstances.pop();
  }
  _modelessChanged(modeless) {
    if (!modeless) {
      if (this.opened) {
        this._addGlobalListeners();
        this._enterModalState();
      }
    } else {
      this._removeGlobalListeners();
      this._exitModalState();
    }
  }
  _addGlobalListeners() {
    document.addEventListener("mousedown", this._boundMouseDownListener);
    document.addEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.addEventListener("click", this._boundOutsideClickListener, true);
    document.addEventListener("keydown", this._boundKeydownListener);
  }
  _enterModalState() {
    if (document.body.style.pointerEvents !== "none") {
      this._previousDocumentPointerEvents = document.body.style.pointerEvents;
      document.body.style.pointerEvents = "none";
    }
    OverlayElement.__attachedInstances.forEach((el) => {
      if (el !== this) {
        el.shadowRoot.querySelector('[part="overlay"]').style.pointerEvents = "none";
      }
    });
  }
  _removeGlobalListeners() {
    document.removeEventListener("mousedown", this._boundMouseDownListener);
    document.removeEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.removeEventListener("click", this._boundOutsideClickListener, true);
    document.removeEventListener("keydown", this._boundKeydownListener);
  }
  _exitModalState() {
    if (this._previousDocumentPointerEvents !== void 0) {
      document.body.style.pointerEvents = this._previousDocumentPointerEvents;
      delete this._previousDocumentPointerEvents;
    }
    const instances = OverlayElement.__attachedInstances;
    let el;
    while (el = instances.pop()) {
      if (el === this) {
        continue;
      }
      el.shadowRoot.querySelector('[part="overlay"]').style.removeProperty("pointer-events");
      if (!el.modeless) {
        break;
      }
    }
  }
  _removeOldContent() {
    if (!this.content || !this._contentNodes) {
      return;
    }
    this._observer.disconnect();
    this._contentNodes.forEach((node) => {
      if (node.parentNode === this.content) {
        this.content.removeChild(node);
      }
    });
    if (this._originalContentPart) {
      this.$.content.parentNode.replaceChild(this._originalContentPart, this.$.content);
      this.$.content = this._originalContentPart;
      this._originalContentPart = void 0;
    }
    this._observer.connect();
    this._contentNodes = void 0;
    this.content = void 0;
  }
  _stampOverlayTemplate(template, instanceProps) {
    this._removeOldContent();
    if (!template._Templatizer) {
      template._Templatizer = templatize(template, this, {
        instanceProps,
        forwardHostProp: function(prop, value) {
          if (this._instance) {
            this._instance.forwardHostProp(prop, value);
          }
        }
      });
    }
    this._instance = new template._Templatizer({});
    this._contentNodes = Array.from(this._instance.root.childNodes);
    const templateRoot = template._templateRoot || (template._templateRoot = template.getRootNode());
    if (templateRoot !== document) {
      if (!this.$.content.shadowRoot) {
        this.$.content.attachShadow({ mode: "open" });
      }
      let scopeCssText = Array.from(templateRoot.querySelectorAll("style")).reduce((result, style) => result + style.textContent, "");
      scopeCssText = scopeCssText.replace(/:host/g, ":host-nomatch");
      if (scopeCssText) {
        const style = document.createElement("style");
        style.textContent = scopeCssText;
        this.$.content.shadowRoot.appendChild(style);
        this._contentNodes.unshift(style);
      }
      this.$.content.shadowRoot.appendChild(this._instance.root);
      this.content = this.$.content.shadowRoot;
    } else {
      this.appendChild(this._instance.root);
      this.content = this;
    }
  }
  _removeNewRendererOrTemplate(template, oldTemplate, renderer, oldRenderer) {
    if (template !== oldTemplate) {
      this.template = void 0;
    } else if (renderer !== oldRenderer) {
      this.renderer = void 0;
    }
  }
  _templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened) {
    if (template && renderer) {
      this._removeNewRendererOrTemplate(template, this._oldTemplate, renderer, this._oldRenderer);
      throw new Error("You should only use either a renderer or a template for overlay content");
    }
    const ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;
    this._oldModel = model;
    this._oldOwner = owner;
    const templateOrInstancePropsChanged = this._oldInstanceProps !== instanceProps || this._oldTemplate !== template;
    this._oldInstanceProps = instanceProps;
    this._oldTemplate = template;
    const rendererChanged = this._oldRenderer !== renderer;
    this._oldRenderer = renderer;
    const openedChanged = this._oldOpened !== opened;
    this._oldOpened = opened;
    if (rendererChanged) {
      this.content = this;
      this.content.innerHTML = "";
      delete this.content._$litPart$;
    }
    if (template && templateOrInstancePropsChanged) {
      this._stampOverlayTemplate(template, instanceProps);
    } else if (renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {
      if (opened) {
        this.requestContentUpdate();
      }
    }
  }
  _isFocused(element) {
    return element && element.getRootNode().activeElement === element;
  }
  _focusedIndex(elements) {
    elements = elements || this._getFocusableElements();
    return elements.indexOf(elements.filter(this._isFocused).pop());
  }
  _cycleTab(increment, index) {
    const focusableElements = this._getFocusableElements();
    if (index === void 0) {
      index = this._focusedIndex(focusableElements);
    }
    index += increment;
    if (index >= focusableElements.length) {
      index = 0;
    } else if (index < 0) {
      index = focusableElements.length - 1;
    }
    focusableElements[index].focus();
  }
  _getFocusableElements() {
    return FocusablesHelper.getTabbableNodes(this.$.overlay);
  }
  _getActiveElement() {
    let active = document.activeElement || document.body;
    while (active.shadowRoot && active.shadowRoot.activeElement) {
      active = active.shadowRoot.activeElement;
    }
    return active;
  }
  _deepContains(node) {
    if (this.contains(node)) {
      return true;
    }
    let n = node;
    const doc = node.ownerDocument;
    while (n && n !== doc && n !== this) {
      n = n.parentNode || n.host;
    }
    return n === this;
  }
  bringToFront() {
    let zIndex = "";
    const frontmost = OverlayElement.__attachedInstances.filter((o) => o !== this).pop();
    if (frontmost) {
      const frontmostZIndex = frontmost.__zIndex;
      zIndex = frontmostZIndex + 1;
    }
    this.style.zIndex = zIndex;
    this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);
  }
};
customElements.define(OverlayElement.is, OverlayElement);

export {
  OverlayElement
};
/**
 * @license
 * Copyright (c) 2021 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-7WSTJGYG.js.map
