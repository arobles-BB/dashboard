import {
  MEDIA_MATCH,
  MIXIN_MATCH,
  VAR_ASSIGN,
  cssBuild,
  detectMixin,
  disableRuntime,
  getComputedStyleValue,
  nativeCssVariables,
  nativeShadow,
  updateNativeProperties
} from "./chunk-VXX3KNUF.js";
import {
  MutableData,
  OptionalMutableData,
  modelForElement,
  templatize
} from "./chunk-GLSLTN6S.js";
import {
  FlattenedNodesObserver,
  calculateSplices
} from "./chunk-WAPH3RCZ.js";
import {
  GestureEventListeners
} from "./chunk-3GXLJMXG.js";
import {
  setTouchAction
} from "./chunk-XLE2I272.js";
import {
  Debouncer
} from "./chunk-CGDXGGUU.js";
import {
  ElementMixin,
  PolymerElement,
  PropertyAccessors,
  PropertyEffects,
  get
} from "./chunk-RZW6ORFJ.js";
import {
  wrap
} from "./chunk-XALJ24ZG.js";
import {
  dedupingMixin
} from "./chunk-GN24F3WZ.js";
import {
  microTask,
  timeOut
} from "./chunk-HDWYYSVS.js";
import {
  legacyOptimizations,
  strictTemplatePolicy
} from "./chunk-FHJNRKKV.js";

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/legacy/polymer.dom.js
var p = Element.prototype;
var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
var matchesSelector = function(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};
var DomApiNative = class {
  constructor(node) {
    this.node = node;
  }
  observeNodes(callback) {
    return new FlattenedNodesObserver(this.node, callback);
  }
  unobserveNodes(observerHandle) {
    observerHandle.disconnect();
  }
  notifyObserver() {
  }
  deepContains(node) {
    if (wrap(this.node).contains(node)) {
      return true;
    }
    let n = node;
    let doc = node.ownerDocument;
    while (n && n !== doc && n !== this.node) {
      n = wrap(n).parentNode || wrap(n).host;
    }
    return n === this.node;
  }
  getOwnerRoot() {
    return wrap(this.node).getRootNode();
  }
  getDistributedNodes() {
    return this.node.localName === "slot" ? wrap(this.node).assignedNodes({ flatten: true }) : [];
  }
  getDestinationInsertionPoints() {
    let ip$ = [];
    let n = wrap(this.node).assignedSlot;
    while (n) {
      ip$.push(n);
      n = wrap(n).assignedSlot;
    }
    return ip$;
  }
  importNode(node, deep) {
    let doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
    return wrap(doc).importNode(node, deep);
  }
  getEffectiveChildNodes() {
    return FlattenedNodesObserver.getFlattenedNodes(this.node);
  }
  queryDistributedElements(selector) {
    let c$ = this.getEffectiveChildNodes();
    let list = [];
    for (let i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
      if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
        list.push(c);
      }
    }
    return list;
  }
  get activeElement() {
    let node = this.node;
    return node._activeElement !== void 0 ? node._activeElement : node.activeElement;
  }
};
function forwardMethods(proto, methods) {
  for (let i = 0; i < methods.length; i++) {
    let method = methods[i];
    proto[method] = function() {
      return this.node[method].apply(this.node, arguments);
    };
  }
}
function forwardReadOnlyProperties(proto, properties) {
  for (let i = 0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        const domApi = this;
        return domApi.node[name];
      },
      configurable: true
    });
  }
}
function forwardProperties(proto, properties) {
  for (let i = 0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        return this.node[name];
      },
      set: function(value) {
        this.node[name] = value;
      },
      configurable: true
    });
  }
}
var EventApi = class {
  constructor(event) {
    this.event = event;
  }
  get rootTarget() {
    return this.path[0];
  }
  get localTarget() {
    return this.event.target;
  }
  get path() {
    return this.event.composedPath();
  }
};
DomApiNative.prototype.cloneNode;
DomApiNative.prototype.appendChild;
DomApiNative.prototype.insertBefore;
DomApiNative.prototype.removeChild;
DomApiNative.prototype.replaceChild;
DomApiNative.prototype.setAttribute;
DomApiNative.prototype.removeAttribute;
DomApiNative.prototype.querySelector;
DomApiNative.prototype.querySelectorAll;
DomApiNative.prototype.parentNode;
DomApiNative.prototype.firstChild;
DomApiNative.prototype.lastChild;
DomApiNative.prototype.nextSibling;
DomApiNative.prototype.previousSibling;
DomApiNative.prototype.firstElementChild;
DomApiNative.prototype.lastElementChild;
DomApiNative.prototype.nextElementSibling;
DomApiNative.prototype.previousElementSibling;
DomApiNative.prototype.childNodes;
DomApiNative.prototype.children;
DomApiNative.prototype.classList;
DomApiNative.prototype.textContent;
DomApiNative.prototype.innerHTML;
var DomApiImpl = DomApiNative;
if (window["ShadyDOM"] && window["ShadyDOM"]["inUse"] && window["ShadyDOM"]["noPatch"] && window["ShadyDOM"]["Wrapper"]) {
  class Wrapper extends window["ShadyDOM"]["Wrapper"] {
  }
  Object.getOwnPropertyNames(DomApiNative.prototype).forEach((prop) => {
    if (prop != "activeElement") {
      Wrapper.prototype[prop] = DomApiNative.prototype[prop];
    }
  });
  forwardReadOnlyProperties(Wrapper.prototype, [
    "classList"
  ]);
  DomApiImpl = Wrapper;
  Object.defineProperties(EventApi.prototype, {
    localTarget: {
      get() {
        return this.event.currentTarget;
      },
      configurable: true
    },
    path: {
      get() {
        return window["ShadyDOM"]["composedPath"](this.event);
      },
      configurable: true
    }
  });
} else {
  forwardMethods(DomApiNative.prototype, [
    "cloneNode",
    "appendChild",
    "insertBefore",
    "removeChild",
    "replaceChild",
    "setAttribute",
    "removeAttribute",
    "querySelector",
    "querySelectorAll"
  ]);
  forwardReadOnlyProperties(DomApiNative.prototype, [
    "parentNode",
    "firstChild",
    "lastChild",
    "nextSibling",
    "previousSibling",
    "firstElementChild",
    "lastElementChild",
    "nextElementSibling",
    "previousElementSibling",
    "childNodes",
    "children",
    "classList"
  ]);
  forwardProperties(DomApiNative.prototype, [
    "textContent",
    "innerHTML"
  ]);
}
var dom = function(obj) {
  obj = obj || document;
  if (obj instanceof DomApiImpl) {
    return obj;
  }
  if (obj instanceof EventApi) {
    return obj;
  }
  let helper = obj["__domApi"];
  if (!helper) {
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApiImpl(obj);
    }
    obj["__domApi"] = helper;
  }
  return helper;
};

// node_modules/.pnpm/@webcomponents/shadycss@1.9.6/node_modules/@webcomponents/shadycss/src/css-parse.js
"use strict";
var StyleNode = class {
  constructor() {
    this["start"] = 0;
    this["end"] = 0;
    this["previous"] = null;
    this["parent"] = null;
    this["rules"] = null;
    this["parsedCssText"] = "";
    this["cssText"] = "";
    this["atRule"] = false;
    this["type"] = 0;
    this["keyframesName"] = "";
    this["selector"] = "";
    this["parsedSelector"] = "";
  }
};
function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
}
function clean(cssText) {
  return cssText.replace(RX.comments, "").replace(RX.port, "");
}
function lex(text) {
  let root = new StyleNode();
  root["start"] = 0;
  root["end"] = text.length;
  let n = root;
  for (let i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n["rules"]) {
        n["rules"] = [];
      }
      let p2 = n;
      let previous = p2["rules"][p2["rules"].length - 1] || null;
      n = new StyleNode();
      n["start"] = i + 1;
      n["parent"] = p2;
      n["previous"] = previous;
      p2["rules"].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n["end"] = i + 1;
      n = n["parent"] || root;
    }
  }
  return root;
}
function parseCss(node, text) {
  let t = text.substring(node["start"], node["end"] - 1);
  node["parsedCssText"] = node["cssText"] = t.trim();
  if (node["parent"]) {
    let ss = node["previous"] ? node["previous"]["end"] : node["parent"]["start"];
    t = text.substring(ss, node["start"] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, " ");
    t = t.substring(t.lastIndexOf(";") + 1);
    let s = node["parsedSelector"] = node["selector"] = t.trim();
    node["atRule"] = s.indexOf(AT_START) === 0;
    if (node["atRule"]) {
      if (s.indexOf(MEDIA_START) === 0) {
        node["type"] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node["type"] = types.KEYFRAMES_RULE;
        node["keyframesName"] = node["selector"].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node["type"] = types.MIXIN_RULE;
      } else {
        node["type"] = types.STYLE_RULE;
      }
    }
  }
  let r$ = node["rules"];
  if (r$) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }
  return node;
}
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
    let code = arguments[1], repeat = 6 - code.length;
    while (repeat--) {
      code = "0" + code;
    }
    return "\\" + code;
  });
}
function stringify(node, preserveProperties, text = "") {
  let cssText = "";
  if (node["cssText"] || node["rules"]) {
    let r$ = node["rules"];
    if (r$ && !_hasMixinRules(r$)) {
      for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node["cssText"] : removeCustomProps(node["cssText"]);
      cssText = cssText.trim();
      if (cssText) {
        cssText = "  " + cssText + "\n";
      }
    }
  }
  if (cssText) {
    if (node["selector"]) {
      text += node["selector"] + " " + OPEN_BRACE + "\n";
    }
    text += cssText;
    if (node["selector"]) {
      text += CLOSE_BRACE + "\n\n";
    }
  }
  return text;
}
function _hasMixinRules(rules) {
  let r = rules[0];
  return Boolean(r) && Boolean(r["selector"]) && r["selector"].indexOf(VAR_START) === 0;
}
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}
function removeCustomPropAssignment(cssText) {
  return cssText.replace(RX.customProp, "").replace(RX.mixinProp, "");
}
function removeCustomPropApply(cssText) {
  return cssText.replace(RX.mixinApply, "").replace(RX.varApply, "");
}
var types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1e3
};
var OPEN_BRACE = "{";
var CLOSE_BRACE = "}";
var RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
};
var VAR_START = "--";
var MEDIA_START = "@media";
var AT_START = "@";

// node_modules/.pnpm/@webcomponents/shadycss@1.9.6/node_modules/@webcomponents/shadycss/src/unscoped-style-handler.js
"use strict";
var styleTextSet = new Set();
var scopingAttribute = "shady-unscoped";
function processUnscopedStyle(style) {
  const text = style.textContent;
  if (!styleTextSet.has(text)) {
    styleTextSet.add(text);
    const newStyle = document.createElement("style");
    newStyle.setAttribute("shady-unscoped", "");
    newStyle.textContent = text;
    document.head.appendChild(newStyle);
  }
}
function isUnscopedStyle(style) {
  return style.hasAttribute(scopingAttribute);
}

// node_modules/.pnpm/@webcomponents/shadycss@1.9.6/node_modules/@webcomponents/shadycss/src/style-util.js
"use strict";
function toCssText(rules, callback) {
  if (!rules) {
    return "";
  }
  if (typeof rules === "string") {
    rules = parse(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return stringify(rules, nativeCssVariables);
}
function rulesForStyle(style) {
  if (!style["__cssRules"] && style.textContent) {
    style["__cssRules"] = parse(style.textContent);
  }
  return style["__cssRules"] || null;
}
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }
  let skipRules = false;
  let type = node["type"];
  if (onlyActiveRules) {
    if (type === types.MEDIA_RULE) {
      let matchMedia = node["selector"].match(MEDIA_MATCH);
      if (matchMedia) {
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === types.STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback && type === types.KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === types.MIXIN_RULE) {
    skipRules = true;
  }
  let r$ = node["rules"];
  if (r$ && !skipRules) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}
function findMatchingParen(text, start) {
  let level = 0;
  for (let i = start, l = text.length; i < l; i++) {
    if (text[i] === "(") {
      level++;
    } else if (text[i] === ")") {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}
function processVariableAndFallback(str, callback) {
  let start = str.indexOf("var(");
  if (start === -1) {
    return callback(str, "", "", "");
  }
  let end = findMatchingParen(str, start + 3);
  let inner = str.substring(start + 4, end);
  let prefix = str.substring(0, start);
  let suffix = processVariableAndFallback(str.substring(end + 1), callback);
  let comma = inner.indexOf(",");
  if (comma === -1) {
    return callback(prefix, inner.trim(), "", suffix);
  }
  let value = inner.substring(0, comma).trim();
  let fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}
var wrap2 = window["ShadyDOM"] && window["ShadyDOM"]["wrap"] || ((node) => node);
function getIsExtends(element) {
  let localName = element["localName"];
  let is = "", typeExtension = "";
  if (localName) {
    if (localName.indexOf("-") > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = element.getAttribute && element.getAttribute("is") || "";
    }
  } else {
    is = element.is;
    typeExtension = element.extends;
  }
  return { is, typeExtension };
}
function gatherStyleText(element) {
  const styleTextParts = [];
  const styles = element.querySelectorAll("style");
  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];
    if (isUnscopedStyle(style)) {
      if (!nativeShadow) {
        processUnscopedStyle(style);
        style.parentNode.removeChild(style);
      }
    } else {
      styleTextParts.push(style.textContent);
      style.parentNode.removeChild(style);
    }
  }
  return styleTextParts.join("").trim();
}
var CSS_BUILD_ATTR = "css-build";
function getCssBuild(element) {
  if (cssBuild !== void 0) {
    return cssBuild;
  }
  if (element.__cssBuild === void 0) {
    const attrValue = element.getAttribute(CSS_BUILD_ATTR);
    if (attrValue) {
      element.__cssBuild = attrValue;
    } else {
      const buildComment = getBuildComment(element);
      if (buildComment !== "") {
        removeBuildComment(element);
      }
      element.__cssBuild = buildComment;
    }
  }
  return element.__cssBuild || "";
}
function elementHasBuiltCss(element) {
  return getCssBuild(element) !== "";
}
function getBuildComment(element) {
  const buildComment = element.localName === "template" ? element.content.firstChild : element.firstChild;
  if (buildComment instanceof Comment) {
    const commentParts = buildComment.textContent.trim().split(":");
    if (commentParts[0] === CSS_BUILD_ATTR) {
      return commentParts[1];
    }
  }
  return "";
}
function removeBuildComment(element) {
  const buildComment = element.localName === "template" ? element.content.firstChild : element.firstChild;
  buildComment.parentNode.removeChild(buildComment);
}

// node_modules/.pnpm/@webcomponents/shadycss@1.9.6/node_modules/@webcomponents/shadycss/src/apply-shim.js
"use strict";
var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
var IMPORTANT = /\s*!important/;
var MIXIN_VAR_SEP = "_-_";
var MixinMap = class {
  constructor() {
    this._map = {};
  }
  set(name, props) {
    name = name.trim();
    this._map[name] = {
      properties: props,
      dependants: {}
    };
  }
  get(name) {
    name = name.trim();
    return this._map[name] || null;
  }
};
var invalidCallback = null;
var ApplyShim = class {
  constructor() {
    this._currentElement = null;
    this._measureElement = null;
    this._map = new MixinMap();
  }
  detectMixin(cssText) {
    return detectMixin(cssText);
  }
  gatherStyles(template) {
    const styleText = gatherStyleText(template.content);
    if (styleText) {
      const style = document.createElement("style");
      style.textContent = styleText;
      template.content.insertBefore(style, template.content.firstChild);
      return style;
    }
    return null;
  }
  transformTemplate(template, elementName) {
    if (template._gatheredStyle === void 0) {
      template._gatheredStyle = this.gatherStyles(template);
    }
    const style = template._gatheredStyle;
    return style ? this.transformStyle(style, elementName) : null;
  }
  transformStyle(style, elementName = "") {
    let ast = rulesForStyle(style);
    this.transformRules(ast, elementName);
    style.textContent = toCssText(ast);
    return ast;
  }
  transformCustomStyle(style) {
    let ast = rulesForStyle(style);
    forEachRule(ast, (rule) => {
      if (rule["selector"] === ":root") {
        rule["selector"] = "html";
      }
      this.transformRule(rule);
    });
    style.textContent = toCssText(ast);
    return ast;
  }
  transformRules(rules, elementName) {
    this._currentElement = elementName;
    forEachRule(rules, (r) => {
      this.transformRule(r);
    });
    this._currentElement = null;
  }
  transformRule(rule) {
    rule["cssText"] = this.transformCssText(rule["parsedCssText"], rule);
    if (rule["selector"] === ":root") {
      rule["selector"] = ":host > *";
    }
  }
  transformCssText(cssText, rule) {
    cssText = cssText.replace(VAR_ASSIGN, (matchText, propertyName, valueProperty, valueMixin) => this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule));
    return this._consumeCssProperties(cssText, rule);
  }
  _getInitialValueForProperty(property) {
    if (!this._measureElement) {
      this._measureElement = document.createElement("meta");
      this._measureElement.setAttribute("apply-shim-measure", "");
      this._measureElement.style.all = "initial";
      document.head.appendChild(this._measureElement);
    }
    return window.getComputedStyle(this._measureElement).getPropertyValue(property);
  }
  _fallbacksFromPreviousRules(startRule) {
    let topRule = startRule;
    while (topRule["parent"]) {
      topRule = topRule["parent"];
    }
    const fallbacks = {};
    let seenStartRule = false;
    forEachRule(topRule, (r) => {
      seenStartRule = seenStartRule || r === startRule;
      if (seenStartRule) {
        return;
      }
      if (r["selector"] === startRule["selector"]) {
        Object.assign(fallbacks, this._cssTextToMap(r["parsedCssText"]));
      }
    });
    return fallbacks;
  }
  _consumeCssProperties(text, rule) {
    let m = null;
    while (m = MIXIN_MATCH.exec(text)) {
      let matchText = m[0];
      let mixinName = m[1];
      let idx = m.index;
      let applyPos = idx + matchText.indexOf("@apply");
      let afterApplyPos = idx + matchText.length;
      let textBeforeApply = text.slice(0, applyPos);
      let textAfterApply = text.slice(afterApplyPos);
      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};
      Object.assign(defaults, this._cssTextToMap(textBeforeApply));
      let replacement = this._atApplyToCssProperties(mixinName, defaults);
      text = `${textBeforeApply}${replacement}${textAfterApply}`;
      MIXIN_MATCH.lastIndex = idx + replacement.length;
    }
    return text;
  }
  _atApplyToCssProperties(mixinName, fallbacks) {
    mixinName = mixinName.replace(APPLY_NAME_CLEAN, "");
    let vars = [];
    let mixinEntry = this._map.get(mixinName);
    if (!mixinEntry) {
      this._map.set(mixinName, {});
      mixinEntry = this._map.get(mixinName);
    }
    if (mixinEntry) {
      if (this._currentElement) {
        mixinEntry.dependants[this._currentElement] = true;
      }
      let p2, parts, f;
      const properties = mixinEntry.properties;
      for (p2 in properties) {
        f = fallbacks && fallbacks[p2];
        parts = [p2, ": var(", mixinName, MIXIN_VAR_SEP, p2];
        if (f) {
          parts.push(",", f.replace(IMPORTANT, ""));
        }
        parts.push(")");
        if (IMPORTANT.test(properties[p2])) {
          parts.push(" !important");
        }
        vars.push(parts.join(""));
      }
    }
    return vars.join("; ");
  }
  _replaceInitialOrInherit(property, value) {
    let match = INITIAL_INHERIT.exec(value);
    if (match) {
      if (match[1]) {
        value = this._getInitialValueForProperty(property);
      } else {
        value = "apply-shim-inherit";
      }
    }
    return value;
  }
  _cssTextToMap(text, replaceInitialOrInherit = false) {
    let props = text.split(";");
    let property, value;
    let out = {};
    for (let i = 0, p2, sp; i < props.length; i++) {
      p2 = props[i];
      if (p2) {
        sp = p2.split(":");
        if (sp.length > 1) {
          property = sp[0].trim();
          value = sp.slice(1).join(":");
          if (replaceInitialOrInherit) {
            value = this._replaceInitialOrInherit(property, value);
          }
          out[property] = value;
        }
      }
    }
    return out;
  }
  _invalidateMixinEntry(mixinEntry) {
    if (!invalidCallback) {
      return;
    }
    for (let elementName in mixinEntry.dependants) {
      if (elementName !== this._currentElement) {
        invalidCallback(elementName);
      }
    }
  }
  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {
    if (valueProperty) {
      processVariableAndFallback(valueProperty, (prefix2, value) => {
        if (value && this._map.get(value)) {
          valueMixin = `@apply ${value};`;
        }
      });
    }
    if (!valueMixin) {
      return matchText;
    }
    let mixinAsProperties = this._consumeCssProperties("" + valueMixin, rule);
    let prefix = matchText.slice(0, matchText.indexOf("--"));
    let mixinValues = this._cssTextToMap(mixinAsProperties, true);
    let combinedProps = mixinValues;
    let mixinEntry = this._map.get(propertyName);
    let oldProps = mixinEntry && mixinEntry.properties;
    if (oldProps) {
      combinedProps = Object.assign(Object.create(oldProps), mixinValues);
    } else {
      this._map.set(propertyName, combinedProps);
    }
    let out = [];
    let p2, v;
    let needToInvalidate = false;
    for (p2 in combinedProps) {
      v = mixinValues[p2];
      if (v === void 0) {
        v = "initial";
      }
      if (oldProps && !(p2 in oldProps)) {
        needToInvalidate = true;
      }
      out.push(`${propertyName}${MIXIN_VAR_SEP}${p2}: ${v}`);
    }
    if (needToInvalidate) {
      this._invalidateMixinEntry(mixinEntry);
    }
    if (mixinEntry) {
      mixinEntry.properties = combinedProps;
    }
    if (valueProperty) {
      prefix = `${matchText};${prefix}`;
    }
    return `${prefix}${out.join("; ")};`;
  }
};
ApplyShim.prototype["detectMixin"] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype["transformStyle"] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype["transformCustomStyle"] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype["transformRules"] = ApplyShim.prototype.transformRules;
ApplyShim.prototype["transformRule"] = ApplyShim.prototype.transformRule;
ApplyShim.prototype["transformTemplate"] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype["_separator"] = MIXIN_VAR_SEP;
Object.defineProperty(ApplyShim.prototype, "invalidCallback", {
  get() {
    return invalidCallback;
  },
  set(cb) {
    invalidCallback = cb;
  }
});
var apply_shim_default = ApplyShim;

// node_modules/.pnpm/@webcomponents/shadycss@1.9.6/node_modules/@webcomponents/shadycss/src/template-map.js
"use strict";
var templateMap = {};
var template_map_default = templateMap;

// node_modules/.pnpm/@webcomponents/shadycss@1.9.6/node_modules/@webcomponents/shadycss/src/apply-shim-utils.js
"use strict";
var CURRENT_VERSION = "_applyShimCurrentVersion";
var NEXT_VERSION = "_applyShimNextVersion";
var VALIDATING_VERSION = "_applyShimValidatingVersion";
var promise = Promise.resolve();
function invalidate(elementName) {
  let template = template_map_default[elementName];
  if (template) {
    invalidateTemplate(template);
  }
}
function invalidateTemplate(template) {
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}
function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}
function startValidatingTemplate(template) {
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  if (!template._validating) {
    template._validating = true;
    promise.then(function() {
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

// node_modules/.pnpm/@webcomponents/shadycss@1.9.6/node_modules/@webcomponents/shadycss/entrypoints/apply-shim.js
"use strict";
var applyShim = new apply_shim_default();
var ApplyShimInterface = class {
  constructor() {
    this.customStyleInterface = null;
    applyShim["invalidCallback"] = invalidate;
  }
  ensure() {
    if (this.customStyleInterface) {
      return;
    }
    if (window.ShadyCSS.CustomStyleInterface) {
      this.customStyleInterface = window.ShadyCSS.CustomStyleInterface;
      this.customStyleInterface["transformCallback"] = (style) => {
        applyShim.transformCustomStyle(style);
      };
      this.customStyleInterface["validateCallback"] = () => {
        requestAnimationFrame(() => {
          if (this.customStyleInterface["enqueued"]) {
            this.flushCustomStyles();
          }
        });
      };
    }
  }
  prepareTemplate(template, elementName) {
    this.ensure();
    if (elementHasBuiltCss(template)) {
      return;
    }
    template_map_default[elementName] = template;
    let ast = applyShim.transformTemplate(template, elementName);
    template["_styleAst"] = ast;
  }
  flushCustomStyles() {
    this.ensure();
    if (!this.customStyleInterface) {
      return;
    }
    let styles = this.customStyleInterface["processStyles"]();
    if (!this.customStyleInterface["enqueued"]) {
      return;
    }
    for (let i = 0; i < styles.length; i++) {
      let cs = styles[i];
      let style = this.customStyleInterface["getStyleForCustomStyle"](cs);
      if (style) {
        applyShim.transformCustomStyle(style);
      }
    }
    this.customStyleInterface["enqueued"] = false;
  }
  styleSubtree(element, properties) {
    this.ensure();
    if (properties) {
      updateNativeProperties(element, properties);
    }
    if (element.shadowRoot) {
      this.styleElement(element);
      let shadowChildren = element.shadowRoot.children || element.shadowRoot.childNodes;
      for (let i = 0; i < shadowChildren.length; i++) {
        this.styleSubtree(shadowChildren[i]);
      }
    } else {
      let children = element.children || element.childNodes;
      for (let i = 0; i < children.length; i++) {
        this.styleSubtree(children[i]);
      }
    }
  }
  styleElement(element) {
    this.ensure();
    let { is } = getIsExtends(element);
    let template = template_map_default[is];
    if (template && elementHasBuiltCss(template)) {
      return;
    }
    if (template && !templateIsValid(template)) {
      if (!templateIsValidating(template)) {
        this.prepareTemplate(template, is);
        startValidatingTemplate(template);
      }
      let root = element.shadowRoot;
      if (root) {
        let style = root.querySelector("style");
        if (style) {
          style["__cssRules"] = template["_styleAst"];
          style.textContent = toCssText(template["_styleAst"]);
        }
      }
    }
  }
  styleDocument(properties) {
    this.ensure();
    this.styleSubtree(document.body, properties);
  }
};
if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  const applyShimInterface = new ApplyShimInterface();
  let CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;
  window.ShadyCSS = {
    prepareTemplate(template, elementName, elementExtends) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName);
    },
    prepareTemplateStyles(template, elementName, elementExtends) {
      window.ShadyCSS.prepareTemplate(template, elementName, elementExtends);
    },
    prepareTemplateDom(template, elementName) {
    },
    styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },
    styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },
    styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },
    getComputedStyleValue(element, property) {
      return getComputedStyleValue(element, property);
    },
    flushCustomStyles() {
      applyShimInterface.flushCustomStyles();
    },
    nativeCss: nativeCssVariables,
    nativeShadow,
    cssBuild,
    disableRuntime
  };
  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}
window.ShadyCSS.ApplyShim = applyShim;

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/mixins/dir-mixin.js
var HOST_DIR = /:host\(:dir\((ltr|rtl)\)\)/g;
var HOST_DIR_REPLACMENT = ':host([dir="$1"])';
var EL_DIR = /([\s\w-#\.\[\]\*]*):dir\((ltr|rtl)\)/g;
var EL_DIR_REPLACMENT = ':host([dir="$2"]) $1';
var DIR_CHECK = /:dir\((?:ltr|rtl)\)/;
var SHIM_SHADOW = Boolean(window["ShadyDOM"] && window["ShadyDOM"]["inUse"]);
var DIR_INSTANCES = [];
var observer = null;
var DOCUMENT_DIR = "";
function getRTL() {
  DOCUMENT_DIR = document.documentElement.getAttribute("dir");
}
function setRTL(instance) {
  if (!instance.__autoDirOptOut) {
    const el = instance;
    el.setAttribute("dir", DOCUMENT_DIR);
  }
}
function updateDirection() {
  getRTL();
  DOCUMENT_DIR = document.documentElement.getAttribute("dir");
  for (let i = 0; i < DIR_INSTANCES.length; i++) {
    setRTL(DIR_INSTANCES[i]);
  }
}
function takeRecords() {
  if (observer && observer.takeRecords().length) {
    updateDirection();
  }
}
var DirMixin = dedupingMixin((base) => {
  if (!SHIM_SHADOW) {
    if (!observer) {
      getRTL();
      observer = new MutationObserver(updateDirection);
      observer.observe(document.documentElement, { attributes: true, attributeFilter: ["dir"] });
    }
  }
  const elementBase = PropertyAccessors(base);
  class Dir extends elementBase {
    static _processStyleText(cssText, baseURI) {
      cssText = super._processStyleText(cssText, baseURI);
      if (!SHIM_SHADOW && DIR_CHECK.test(cssText)) {
        cssText = this._replaceDirInCssText(cssText);
        this.__activateDir = true;
      }
      return cssText;
    }
    static _replaceDirInCssText(text) {
      let replacedText = text;
      replacedText = replacedText.replace(HOST_DIR, HOST_DIR_REPLACMENT);
      replacedText = replacedText.replace(EL_DIR, EL_DIR_REPLACMENT);
      return replacedText;
    }
    constructor() {
      super();
      this.__autoDirOptOut = false;
    }
    ready() {
      super.ready();
      this.__autoDirOptOut = this.hasAttribute("dir");
    }
    connectedCallback() {
      if (elementBase.prototype.connectedCallback) {
        super.connectedCallback();
      }
      if (this.constructor.__activateDir) {
        takeRecords();
        DIR_INSTANCES.push(this);
        setRTL(this);
      }
    }
    disconnectedCallback() {
      if (elementBase.prototype.disconnectedCallback) {
        super.disconnectedCallback();
      }
      if (this.constructor.__activateDir) {
        const idx = DIR_INSTANCES.indexOf(this);
        if (idx > -1) {
          DIR_INSTANCES.splice(idx, 1);
        }
      }
    }
  }
  Dir.__activateDir = false;
  return Dir;
});

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/utils/unresolved.js
function resolve() {
  document.body.removeAttribute("unresolved");
}
if (document.readyState === "interactive" || document.readyState === "complete") {
  resolve();
} else {
  window.addEventListener("DOMContentLoaded", resolve);
}

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/legacy/legacy-element-mixin.js
var styleInterface = window.ShadyCSS;
var LegacyElementMixin = dedupingMixin((base) => {
  const legacyElementBase = DirMixin(GestureEventListeners(ElementMixin(base)));
  const DIRECTION_MAP = {
    "x": "pan-x",
    "y": "pan-y",
    "none": "none",
    "all": "auto"
  };
  class LegacyElement extends legacyElementBase {
    constructor() {
      super();
      this.isAttached;
      this.__boundListeners;
      this._debouncers;
    }
    static get importMeta() {
      return this.prototype.importMeta;
    }
    created() {
    }
    connectedCallback() {
      super.connectedCallback();
      this.isAttached = true;
      this.attached();
    }
    attached() {
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this.isAttached = false;
      this.detached();
    }
    detached() {
    }
    attributeChangedCallback(name, old, value, namespace) {
      if (old !== value) {
        super.attributeChangedCallback(name, old, value, namespace);
        this.attributeChanged(name, old, value);
      }
    }
    attributeChanged(name, old, value) {
    }
    _initializeProperties() {
      let proto = Object.getPrototypeOf(this);
      if (!proto.hasOwnProperty("__hasRegisterFinished")) {
        this._registered();
        proto.__hasRegisterFinished = true;
      }
      super._initializeProperties();
      this.root = this;
      this.created();
      this._applyListeners();
    }
    _registered() {
    }
    ready() {
      this._ensureAttributes();
      super.ready();
    }
    _ensureAttributes() {
    }
    _applyListeners() {
    }
    serialize(value) {
      return this._serializeValue(value);
    }
    deserialize(value, type) {
      return this._deserializeValue(value, type);
    }
    reflectPropertyToAttribute(property, attribute, value) {
      this._propertyToAttribute(property, attribute, value);
    }
    serializeValueToAttribute(value, attribute, node) {
      this._valueToNodeAttribute(node || this, value, attribute);
    }
    extend(prototype, api) {
      if (!(prototype && api)) {
        return prototype || api;
      }
      let n$ = Object.getOwnPropertyNames(api);
      for (let i = 0, n; i < n$.length && (n = n$[i]); i++) {
        let pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          Object.defineProperty(prototype, n, pd);
        }
      }
      return prototype;
    }
    mixin(target, source) {
      for (let i in source) {
        target[i] = source[i];
      }
      return target;
    }
    chainObject(object, prototype) {
      if (object && prototype && object !== prototype) {
        object.__proto__ = prototype;
      }
      return object;
    }
    instanceTemplate(template) {
      let content = this.constructor._contentForTemplate(template);
      let dom2 = document.importNode(content, true);
      return dom2;
    }
    fire(type, detail, options) {
      options = options || {};
      detail = detail === null || detail === void 0 ? {} : detail;
      let event = new Event(type, {
        bubbles: options.bubbles === void 0 ? true : options.bubbles,
        cancelable: Boolean(options.cancelable),
        composed: options.composed === void 0 ? true : options.composed
      });
      event.detail = detail;
      let node = options.node || this;
      wrap(node).dispatchEvent(event);
      return event;
    }
    listen(node, eventName, methodName) {
      node = node || this;
      let hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
      let bl = hbl.get(node);
      if (!bl) {
        bl = {};
        hbl.set(node, bl);
      }
      let key = eventName + methodName;
      if (!bl[key]) {
        bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
      }
    }
    unlisten(node, eventName, methodName) {
      node = node || this;
      let bl = this.__boundListeners && this.__boundListeners.get(node);
      let key = eventName + methodName;
      let handler = bl && bl[key];
      if (handler) {
        this._removeEventListenerFromNode(node, eventName, handler);
        bl[key] = null;
      }
    }
    setScrollDirection(direction, node) {
      setTouchAction(node || this, DIRECTION_MAP[direction] || "auto");
    }
    $$(slctr) {
      return this.root.querySelector(slctr);
    }
    get domHost() {
      let root = wrap(this).getRootNode();
      return root instanceof DocumentFragment ? root.host : root;
    }
    distributeContent() {
      const thisEl = this;
      const domApi = dom(thisEl);
      if (window.ShadyDOM && domApi.shadowRoot) {
        ShadyDOM.flush();
      }
    }
    getEffectiveChildNodes() {
      const thisEl = this;
      const domApi = dom(thisEl);
      return domApi.getEffectiveChildNodes();
    }
    queryDistributedElements(selector) {
      const thisEl = this;
      const domApi = dom(thisEl);
      return domApi.queryDistributedElements(selector);
    }
    getEffectiveChildren() {
      let list = this.getEffectiveChildNodes();
      return list.filter(function(n) {
        return n.nodeType === Node.ELEMENT_NODE;
      });
    }
    getEffectiveTextContent() {
      let cn = this.getEffectiveChildNodes();
      let tc = [];
      for (let i = 0, c; c = cn[i]; i++) {
        if (c.nodeType !== Node.COMMENT_NODE) {
          tc.push(c.textContent);
        }
      }
      return tc.join("");
    }
    queryEffectiveChildren(selector) {
      let e$ = this.queryDistributedElements(selector);
      return e$ && e$[0];
    }
    queryAllEffectiveChildren(selector) {
      return this.queryDistributedElements(selector);
    }
    getContentChildNodes(slctr) {
      let content = this.root.querySelector(slctr || "slot");
      return content ? dom(content).getDistributedNodes() : [];
    }
    getContentChildren(slctr) {
      let children = this.getContentChildNodes(slctr).filter(function(n) {
        return n.nodeType === Node.ELEMENT_NODE;
      });
      return children;
    }
    isLightDescendant(node) {
      const thisNode = this;
      return thisNode !== node && wrap(thisNode).contains(node) && wrap(thisNode).getRootNode() === wrap(node).getRootNode();
    }
    isLocalDescendant(node) {
      return this.root === wrap(node).getRootNode();
    }
    scopeSubtree(container, shouldObserve) {
    }
    getComputedStyleValue(property) {
      return styleInterface.getComputedStyleValue(this, property);
    }
    debounce(jobName, callback, wait) {
      this._debouncers = this._debouncers || {};
      return this._debouncers[jobName] = Debouncer.debounce(this._debouncers[jobName], wait > 0 ? timeOut.after(wait) : microTask, callback.bind(this));
    }
    isDebouncerActive(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      return !!(debouncer && debouncer.isActive());
    }
    flushDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.flush();
      }
    }
    cancelDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.cancel();
      }
    }
    async(callback, waitTime) {
      return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) : ~microTask.run(callback.bind(this));
    }
    cancelAsync(handle) {
      handle < 0 ? microTask.cancel(~handle) : timeOut.cancel(handle);
    }
    create(tag, props) {
      let elt = document.createElement(tag);
      if (props) {
        if (elt.setProperties) {
          elt.setProperties(props);
        } else {
          for (let n in props) {
            elt[n] = props[n];
          }
        }
      }
      return elt;
    }
    elementMatches(selector, node) {
      return matchesSelector(node || this, selector);
    }
    toggleAttribute(name, bool) {
      let node = this;
      if (arguments.length === 3) {
        node = arguments[2];
      }
      if (arguments.length == 1) {
        bool = !node.hasAttribute(name);
      }
      if (bool) {
        wrap(node).setAttribute(name, "");
        return true;
      } else {
        wrap(node).removeAttribute(name);
        return false;
      }
    }
    toggleClass(name, bool, node) {
      node = node || this;
      if (arguments.length == 1) {
        bool = !node.classList.contains(name);
      }
      if (bool) {
        node.classList.add(name);
      } else {
        node.classList.remove(name);
      }
    }
    transform(transformText, node) {
      node = node || this;
      node.style.webkitTransform = transformText;
      node.style.transform = transformText;
    }
    translate3d(x, y, z, node) {
      node = node || this;
      this.transform("translate3d(" + x + "," + y + "," + z + ")", node);
    }
    arrayDelete(arrayOrPath, item) {
      let index;
      if (Array.isArray(arrayOrPath)) {
        index = arrayOrPath.indexOf(item);
        if (index >= 0) {
          return arrayOrPath.splice(index, 1);
        }
      } else {
        let arr = get(this, arrayOrPath);
        index = arr.indexOf(item);
        if (index >= 0) {
          return this.splice(arrayOrPath, index, 1);
        }
      }
      return null;
    }
    _logger(level, args) {
      if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {
        args = args[0];
      }
      switch (level) {
        case "log":
        case "warn":
        case "error":
          console[level](...args);
      }
    }
    _log(...args) {
      this._logger("log", args);
    }
    _warn(...args) {
      this._logger("warn", args);
    }
    _error(...args) {
      this._logger("error", args);
    }
    _logf(methodName, ...args) {
      return ["[%s::%s]", this.is, methodName, ...args];
    }
  }
  LegacyElement.prototype.is = "";
  return LegacyElement;
});

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/legacy/class.js
var lifecycleProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  listeners: true,
  hostAttributes: true
};
var excludeOnInfo = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  behaviors: true,
  _noAccessors: true
};
var excludeOnBehaviors = Object.assign({
  listeners: true,
  hostAttributes: true,
  properties: true,
  observers: true
}, excludeOnInfo);
function copyProperties(source, target, excludeProps) {
  const noAccessors = source._noAccessors;
  const propertyNames = Object.getOwnPropertyNames(source);
  for (let i = 0; i < propertyNames.length; i++) {
    let p2 = propertyNames[i];
    if (p2 in excludeProps) {
      continue;
    }
    if (noAccessors) {
      target[p2] = source[p2];
    } else {
      let pd = Object.getOwnPropertyDescriptor(source, p2);
      if (pd) {
        pd.configurable = true;
        Object.defineProperty(target, p2, pd);
      }
    }
  }
}
function mixinBehaviors(behaviors, klass) {
  return GenerateClassFromInfo({}, LegacyElementMixin(klass), behaviors);
}
function applyBehaviors(proto, behaviors, lifecycle) {
  for (let i = 0; i < behaviors.length; i++) {
    applyInfo(proto, behaviors[i], lifecycle, excludeOnBehaviors);
  }
}
function applyInfo(proto, info, lifecycle, excludeProps) {
  copyProperties(info, proto, excludeProps);
  for (let p2 in lifecycleProps) {
    if (info[p2]) {
      lifecycle[p2] = lifecycle[p2] || [];
      lifecycle[p2].push(info[p2]);
    }
  }
}
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (let i = behaviors.length - 1; i >= 0; i--) {
    let b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn("behavior is null, check for missing or 404 import");
    }
  }
  return list;
}
function mergeProperties(target, source) {
  for (const p2 in source) {
    const targetInfo = target[p2];
    const sourceInfo = source[p2];
    if (!("value" in sourceInfo) && targetInfo && "value" in targetInfo) {
      target[p2] = Object.assign({ value: targetInfo.value }, sourceInfo);
    } else {
      target[p2] = sourceInfo;
    }
  }
}
function GenerateClassFromInfo(info, Base2, behaviors) {
  let behaviorList;
  const lifecycle = {};
  class PolymerGenerated extends Base2 {
    static _finalizeClass() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("generatedFrom", this))) {
        super._finalizeClass();
      } else {
        if (behaviorList) {
          for (let i = 0, b; i < behaviorList.length; i++) {
            b = behaviorList[i];
            if (b.properties) {
              this.createProperties(b.properties);
            }
            if (b.observers) {
              this.createObservers(b.observers, b.properties);
            }
          }
        }
        if (info.properties) {
          this.createProperties(info.properties);
        }
        if (info.observers) {
          this.createObservers(info.observers, info.properties);
        }
        this._prepareTemplate();
      }
    }
    static get properties() {
      const properties = {};
      if (behaviorList) {
        for (let i = 0; i < behaviorList.length; i++) {
          mergeProperties(properties, behaviorList[i].properties);
        }
      }
      mergeProperties(properties, info.properties);
      return properties;
    }
    static get observers() {
      let observers = [];
      if (behaviorList) {
        for (let i = 0, b; i < behaviorList.length; i++) {
          b = behaviorList[i];
          if (b.observers) {
            observers = observers.concat(b.observers);
          }
        }
      }
      if (info.observers) {
        observers = observers.concat(info.observers);
      }
      return observers;
    }
    created() {
      super.created();
      const list = lifecycle.created;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    _registered() {
      const generatedProto = PolymerGenerated.prototype;
      if (!generatedProto.hasOwnProperty("__hasRegisterFinished")) {
        generatedProto.__hasRegisterFinished = true;
        super._registered();
        if (legacyOptimizations) {
          copyPropertiesToProto(generatedProto);
        }
        const proto = Object.getPrototypeOf(this);
        let list = lifecycle.beforeRegister;
        if (list) {
          for (let i = 0; i < list.length; i++) {
            list[i].call(proto);
          }
        }
        list = lifecycle.registered;
        if (list) {
          for (let i = 0; i < list.length; i++) {
            list[i].call(proto);
          }
        }
      }
    }
    _applyListeners() {
      super._applyListeners();
      const list = lifecycle.listeners;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          const listeners = list[i];
          if (listeners) {
            for (let l in listeners) {
              this._addMethodEventListenerToNode(this, l, listeners[l]);
            }
          }
        }
      }
    }
    _ensureAttributes() {
      const list = lifecycle.hostAttributes;
      if (list) {
        for (let i = list.length - 1; i >= 0; i--) {
          const hostAttributes = list[i];
          for (let a in hostAttributes) {
            this._ensureAttribute(a, hostAttributes[a]);
          }
        }
      }
      super._ensureAttributes();
    }
    ready() {
      super.ready();
      let list = lifecycle.ready;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    attached() {
      super.attached();
      let list = lifecycle.attached;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    detached() {
      super.detached();
      let list = lifecycle.detached;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }
    attributeChanged(name, old, value) {
      super.attributeChanged();
      let list = lifecycle.attributeChanged;
      if (list) {
        for (let i = 0; i < list.length; i++) {
          list[i].call(this, name, old, value);
        }
      }
    }
  }
  if (behaviors) {
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    let superBehaviors = Base2.prototype.behaviors;
    behaviorList = flattenBehaviors(behaviors, null, superBehaviors);
    PolymerGenerated.prototype.behaviors = superBehaviors ? superBehaviors.concat(behaviors) : behaviorList;
  }
  const copyPropertiesToProto = (proto) => {
    if (behaviorList) {
      applyBehaviors(proto, behaviorList, lifecycle);
    }
    applyInfo(proto, info, lifecycle, excludeOnInfo);
  };
  if (!legacyOptimizations) {
    copyPropertiesToProto(PolymerGenerated.prototype);
  }
  PolymerGenerated.generatedFrom = info;
  return PolymerGenerated;
}
var Class = function(info, mixin) {
  if (!info) {
    console.warn("Polymer.Class requires `info` argument");
  }
  let klass = mixin ? mixin(LegacyElementMixin(HTMLElement)) : LegacyElementMixin(HTMLElement);
  klass = GenerateClassFromInfo(info, klass, info.behaviors);
  klass.is = klass.prototype.is = info.is;
  return klass;
};

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/legacy/polymer-fn.js
var Polymer = function(info) {
  let klass;
  if (typeof info === "function") {
    klass = info;
  } else {
    klass = Polymer.Class(info);
  }
  customElements.define(klass.is, klass);
  return klass;
};
Polymer.Class = Class;

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/legacy/templatizer-behavior.js
var Templatizer = {
  templatize(template, mutableData) {
    this._templatizerTemplate = template;
    this.ctor = templatize(template, this, {
      mutableData: Boolean(mutableData),
      parentModel: this._parentModel,
      instanceProps: this._instanceProps,
      forwardHostProp: this._forwardHostPropV2,
      notifyInstanceProp: this._notifyInstancePropV2
    });
  },
  stamp(model) {
    return new this.ctor(model);
  },
  modelForElement(el) {
    return modelForElement(this._templatizerTemplate, el);
  }
};

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/legacy/mutable-data-behavior.js
var mutablePropertyChange;
(() => {
  mutablePropertyChange = MutableData._mutablePropertyChange;
})();
var OptionalMutableDataBehavior = {
  properties: {
    mutableData: Boolean
  },
  _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, this.mutableData);
  }
};

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/elements/dom-bind.js
var domBindBase = GestureEventListeners(OptionalMutableData(PropertyEffects(HTMLElement)));
var DomBind = class extends domBindBase {
  static get observedAttributes() {
    return ["mutable-data"];
  }
  constructor() {
    super();
    if (strictTemplatePolicy) {
      throw new Error(`strictTemplatePolicy: dom-bind not allowed`);
    }
    this.root = null;
    this.$ = null;
    this.__children = null;
  }
  attributeChangedCallback() {
    this.mutableData = true;
  }
  connectedCallback() {
    this.style.display = "none";
    this.render();
  }
  disconnectedCallback() {
    this.__removeChildren();
  }
  __insertChildren() {
    wrap(wrap(this).parentNode).insertBefore(this.root, this);
  }
  __removeChildren() {
    if (this.__children) {
      for (let i = 0; i < this.__children.length; i++) {
        this.root.appendChild(this.__children[i]);
      }
    }
  }
  render() {
    let template;
    if (!this.__children) {
      template = template || this.querySelector("template");
      if (!template) {
        let observer2 = new MutationObserver(() => {
          template = this.querySelector("template");
          if (template) {
            observer2.disconnect();
            this.render();
          } else {
            throw new Error("dom-bind requires a <template> child");
          }
        });
        observer2.observe(this, { childList: true });
        return;
      }
      this.root = this._stampTemplate(template);
      this.$ = this.root.$;
      this.__children = [];
      for (let n = this.root.firstChild; n; n = n.nextSibling) {
        this.__children[this.__children.length] = n;
      }
      this._enableProperties();
    }
    this.__insertChildren();
    this.dispatchEvent(new CustomEvent("dom-change", {
      bubbles: true,
      composed: true
    }));
  }
};
customElements.define("dom-bind", DomBind);

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/lib/elements/array-selector.js
var ArraySelectorMixin = dedupingMixin((superClass) => {
  let elementBase = ElementMixin(superClass);
  class ArraySelectorMixin2 extends elementBase {
    static get properties() {
      return {
        items: {
          type: Array
        },
        multi: {
          type: Boolean,
          value: false
        },
        selected: { type: Object, notify: true },
        selectedItem: { type: Object, notify: true },
        toggle: { type: Boolean, value: false }
      };
    }
    static get observers() {
      return ["__updateSelection(multi, items.*)"];
    }
    constructor() {
      super();
      this.__lastItems = null;
      this.__lastMulti = null;
      this.__selectedMap = null;
    }
    __updateSelection(multi, itemsInfo) {
      let path = itemsInfo.path;
      if (path == JSCompiler_renameProperty("items", this)) {
        let newItems = itemsInfo.base || [];
        let lastItems = this.__lastItems;
        let lastMulti = this.__lastMulti;
        if (multi !== lastMulti) {
          this.clearSelection();
        }
        if (lastItems) {
          let splices = calculateSplices(newItems, lastItems);
          this.__applySplices(splices);
        }
        this.__lastItems = newItems;
        this.__lastMulti = multi;
      } else if (itemsInfo.path == `${JSCompiler_renameProperty("items", this)}.splices`) {
        this.__applySplices(itemsInfo.value.indexSplices);
      } else {
        let part = path.slice(`${JSCompiler_renameProperty("items", this)}.`.length);
        let idx = parseInt(part, 10);
        if (part.indexOf(".") < 0 && part == idx) {
          this.__deselectChangedIdx(idx);
        }
      }
    }
    __applySplices(splices) {
      let selected = this.__selectedMap;
      for (let i = 0; i < splices.length; i++) {
        let s = splices[i];
        selected.forEach((idx, item) => {
          if (idx < s.index) {
          } else if (idx >= s.index + s.removed.length) {
            selected.set(item, idx + s.addedCount - s.removed.length);
          } else {
            selected.set(item, -1);
          }
        });
        for (let j = 0; j < s.addedCount; j++) {
          let idx = s.index + j;
          if (selected.has(this.items[idx])) {
            selected.set(this.items[idx], idx);
          }
        }
      }
      this.__updateLinks();
      let sidx = 0;
      selected.forEach((idx, item) => {
        if (idx < 0) {
          if (this.multi) {
            this.splice(JSCompiler_renameProperty("selected", this), sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
          selected.delete(item);
        } else {
          sidx++;
        }
      });
    }
    __updateLinks() {
      this.__dataLinkedPaths = {};
      if (this.multi) {
        let sidx = 0;
        this.__selectedMap.forEach((idx) => {
          if (idx >= 0) {
            this.linkPaths(`${JSCompiler_renameProperty("items", this)}.${idx}`, `${JSCompiler_renameProperty("selected", this)}.${sidx++}`);
          }
        });
      } else {
        this.__selectedMap.forEach((idx) => {
          this.linkPaths(JSCompiler_renameProperty("selected", this), `${JSCompiler_renameProperty("items", this)}.${idx}`);
          this.linkPaths(JSCompiler_renameProperty("selectedItem", this), `${JSCompiler_renameProperty("items", this)}.${idx}`);
        });
      }
    }
    clearSelection() {
      this.__dataLinkedPaths = {};
      this.__selectedMap = new Map();
      this.selected = this.multi ? [] : null;
      this.selectedItem = null;
    }
    isSelected(item) {
      return this.__selectedMap.has(item);
    }
    isIndexSelected(idx) {
      return this.isSelected(this.items[idx]);
    }
    __deselectChangedIdx(idx) {
      let sidx = this.__selectedIndexForItemIndex(idx);
      if (sidx >= 0) {
        let i = 0;
        this.__selectedMap.forEach((idx2, item) => {
          if (sidx == i++) {
            this.deselect(item);
          }
        });
      }
    }
    __selectedIndexForItemIndex(idx) {
      let selected = this.__dataLinkedPaths[`${JSCompiler_renameProperty("items", this)}.${idx}`];
      if (selected) {
        return parseInt(selected.slice(`${JSCompiler_renameProperty("selected", this)}.`.length), 10);
      }
    }
    deselect(item) {
      let idx = this.__selectedMap.get(item);
      if (idx >= 0) {
        this.__selectedMap.delete(item);
        let sidx;
        if (this.multi) {
          sidx = this.__selectedIndexForItemIndex(idx);
        }
        this.__updateLinks();
        if (this.multi) {
          this.splice(JSCompiler_renameProperty("selected", this), sidx, 1);
        } else {
          this.selected = this.selectedItem = null;
        }
      }
    }
    deselectIndex(idx) {
      this.deselect(this.items[idx]);
    }
    select(item) {
      this.selectIndex(this.items.indexOf(item));
    }
    selectIndex(idx) {
      let item = this.items[idx];
      if (!this.isSelected(item)) {
        if (!this.multi) {
          this.__selectedMap.clear();
        }
        this.__selectedMap.set(item, idx);
        this.__updateLinks();
        if (this.multi) {
          this.push(JSCompiler_renameProperty("selected", this), item);
        } else {
          this.selected = this.selectedItem = item;
        }
      } else if (this.toggle) {
        this.deselectIndex(idx);
      }
    }
  }
  return ArraySelectorMixin2;
});
var baseArraySelector = ArraySelectorMixin(PolymerElement);
var ArraySelector = class extends baseArraySelector {
  static get is() {
    return "array-selector";
  }
  static get template() {
    return null;
  }
};
customElements.define(ArraySelector.is, ArraySelector);

// node_modules/.pnpm/@polymer/polymer@3.2.0/node_modules/@polymer/polymer/polymer-legacy.js
var Base = LegacyElementMixin(HTMLElement).prototype;

export {
  dom,
  mixinBehaviors,
  Polymer,
  Templatizer,
  OptionalMutableDataBehavior,
  Base
};
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
//# sourceMappingURL=chunk-F75XGNCT.js.map
