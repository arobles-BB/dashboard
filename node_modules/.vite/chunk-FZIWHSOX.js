import {
  CSSResult
} from "./chunk-TZPBKG4Y.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-GWBPVOL2.js";

// node_modules/.pnpm/@vaadin/vaadin-themable-mixin@22.0.2/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js
var ThemePropertyMixin = (superClass) => class VaadinThemePropertyMixin extends superClass {
  static get properties() {
    return {
      theme: {
        type: String,
        readOnly: true
      }
    };
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name === "theme") {
      this._setTheme(newValue);
    }
  }
};

// node_modules/.pnpm/@vaadin/vaadin-themable-mixin@22.0.2/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js
var themeRegistry = [];
function registerStyles(themeFor, styles, options = {}) {
  if (themeFor) {
    const elementClass = customElements.get(themeFor);
    if (elementClass && Object.prototype.hasOwnProperty.call(elementClass, "__finalized")) {
      console.warn(`The custom element definition for "${themeFor}"
      was finalized before a style module was registered.
      Make sure to add component specific style modules before
      importing the corresponding custom element.`);
    }
  }
  styles = recursiveFlattenStyles(styles);
  if (window.Vaadin && window.Vaadin.styleModules) {
    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);
  } else {
    themeRegistry.push({
      themeFor,
      styles,
      include: options.include,
      moduleId: options.moduleId
    });
  }
}
function getAllThemes() {
  if (window.Vaadin && window.Vaadin.styleModules) {
    return window.Vaadin.styleModules.getAllThemes();
  } else {
    return themeRegistry;
  }
}
function matchesThemeFor(themeFor, tagName) {
  return (themeFor || "").split(" ").some((themeForToken) => {
    return new RegExp("^" + themeForToken.split("*").join(".*") + "$").test(tagName);
  });
}
function getIncludePriority(moduleName = "") {
  let includePriority = 0;
  if (moduleName.indexOf("lumo-") === 0 || moduleName.indexOf("material-") === 0) {
    includePriority = 1;
  } else if (moduleName.indexOf("vaadin-") === 0) {
    includePriority = 2;
  }
  return includePriority;
}
function recursiveFlattenStyles(styles = [], result = []) {
  if (styles instanceof CSSResult) {
    result.push(styles);
  } else if (Array.isArray(styles)) {
    styles.forEach((style) => recursiveFlattenStyles(style, result));
  } else {
    console.warn("An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.");
  }
  return result;
}
function getIncludedStyles(theme) {
  const includedStyles = [];
  if (theme.include) {
    [].concat(theme.include).forEach((includeModuleId) => {
      const includedTheme = getAllThemes().find((s) => s.moduleId === includeModuleId);
      if (includedTheme) {
        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);
      } else {
        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);
      }
    }, theme.styles);
  }
  return includedStyles;
}
function addStylesToTemplate(styles, template) {
  const styleEl = document.createElement("style");
  styleEl.innerHTML = styles.filter((style, index) => index === styles.lastIndexOf(style)).map((style) => style.cssText).join("\n");
  template.content.appendChild(styleEl);
}
function getThemes(tagName) {
  const defaultModuleName = tagName + "-default-theme";
  const themes = getAllThemes().filter((theme) => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName)).map((theme) => __spreadProps(__spreadValues({}, theme), {
    styles: [...getIncludedStyles(theme), ...theme.styles],
    includePriority: getIncludePriority(theme.moduleId)
  })).sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);
  if (themes.length > 0) {
    return themes;
  } else {
    return getAllThemes().filter((theme) => theme.moduleId === defaultModuleName);
  }
}
var ThemableMixin = (superClass) => class VaadinThemableMixin extends ThemePropertyMixin(superClass) {
  static finalize() {
    super.finalize();
    const template = this.prototype._template;
    if (!template || template.__themes) {
      return;
    }
    const inheritedTemplate = Object.getPrototypeOf(this.prototype)._template;
    const inheritedThemes = (inheritedTemplate ? inheritedTemplate.__themes : []) || [];
    template.__themes = [...inheritedThemes, ...getThemes(this.is)];
    const styles = template.__themes.reduce((styles2, theme) => [...styles2, ...theme.styles], []);
    addStylesToTemplate(styles, template);
  }
  static finalizeStyles(styles) {
    return getThemes(this.is).reduce((styles2, theme) => [...styles2, ...theme.styles], []).concat(styles);
  }
};

export {
  ThemePropertyMixin,
  themeRegistry,
  registerStyles,
  ThemableMixin
};
/**
 * @license
 * Copyright (c) 2021 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=chunk-FZIWHSOX.js.map
