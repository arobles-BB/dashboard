{
  "version": 3,
  "sources": ["../.pnpm/@vaadin/component-base@22.0.2/node_modules/@vaadin/component-base/src/iron-list-core.js", "../.pnpm/@vaadin/component-base@22.0.2/node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js", "../.pnpm/@vaadin/component-base@22.0.2/node_modules/@vaadin/component-base/src/virtualizer.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { animationFrame, idlePeriod, microTask } from './async.js';\nimport { Debouncer, enqueueDebouncer, flush } from './debounce.js';\n\nconst IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/);\nconst IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nconst DEFAULT_PHYSICAL_COUNT = 3;\n\n/**\n * @private\n */\nexport const ironList = {\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n\n  /**\n   * The maximum items per row\n   */\n  _itemsPerRow: 1,\n\n  /**\n   * The width of each grid item\n   */\n  _itemWidth: 0,\n\n  /**\n   * The height of the row in grid layout.\n   */\n  _rowHeight: 0,\n\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n\n  /**\n   * Needed to pass event.model property to declarative event handlers -\n   * see polymer/polymer#4339.\n   */\n  _parentModel: true,\n\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    var size = this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;\n    return size - this._viewportHeight;\n  },\n\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    var virtualCount = this._convertIndexToCompleteRow(this._virtualCount);\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    if (this.grid) {\n      val = val - (val % this._itemsPerRow);\n    }\n    this._virtualStartVal = val;\n  },\n\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val = val % this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    if (this.grid) {\n      val = val - (val % this._itemsPerRow);\n    }\n    this._physicalStartVal = val;\n  },\n\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    var idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      var physicalOffset = this._physicalTop + this._scrollOffset;\n\n      idx =\n        this._iterateItems(function (pidx, vidx) {\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n\n          if (physicalOffset > this._scrollPosition) {\n            return this.grid ? vidx - (vidx % this._itemsPerRow) : vidx;\n          }\n          // Handle a partially rendered final row in grid mode\n          if (this.grid && this._virtualCount - 1 === vidx) {\n            return vidx - (vidx % this._itemsPerRow);\n          }\n        }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    var idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      if (this.grid) {\n        idx = Math.min(this._virtualCount, this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow - 1);\n      } else {\n        var physicalOffset = this._physicalTop + this._scrollOffset;\n        this._iterateItems(function (pidx, vidx) {\n          if (physicalOffset < this._scrollBottom) {\n            idx = vidx;\n          }\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n        });\n      }\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  get _defaultScrollTarget() {\n    return this;\n  },\n\n  get _virtualRowCount() {\n    return Math.ceil(this._virtualCount / this._itemsPerRow);\n  },\n\n  get _estRowsInView() {\n    return Math.ceil(this._viewportHeight / this._rowHeight);\n  },\n\n  get _physicalRows() {\n    return Math.ceil(this._physicalCount / this._itemsPerRow);\n  },\n\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler: function () {\n    var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    var delta = scrollTop - this._scrollPosition;\n    var isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta = delta - this._scrollOffset;\n      var idxAdjustment = Math.round(delta / this._physicalAverage) * this._itemsPerRow;\n      this._virtualStart = this._virtualStart + idxAdjustment;\n      this._physicalStart = this._physicalStart + idxAdjustment;\n      // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n      this._physicalTop = Math.min(\n        Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage,\n        this._scrollPosition\n      );\n      this._update();\n    } else if (this._physicalCount > 0) {\n      var reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart = this._virtualStart + reusables.indexes.length;\n        this._physicalStart = this._physicalStart + reusables.indexes.length;\n      } else {\n        this._virtualStart = this._virtualStart - reusables.indexes.length;\n        this._physicalStart = this._physicalStart - reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), microTask);\n    }\n  },\n\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables: function (fromTop) {\n    var ith, lastIth, offsetContent, physicalItemHeight;\n    var idxs = [];\n    var protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    var virtualStart = this._virtualStart;\n    var virtualEnd = this._virtualEnd;\n    var physicalCount = this._physicalCount;\n    var top = this._physicalTop + this._scrollOffset;\n    var bottom = this._physicalBottom + this._scrollOffset;\n    // This may be called outside of a scrollHandler, so use last cached position\n    var scrollTop = this._scrollPosition;\n    var scrollBottom = this._scrollBottom;\n\n    if (fromTop) {\n      ith = this._physicalStart;\n      lastIth = this._physicalEnd;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      lastIth = this._physicalStart;\n      offsetContent = bottom - scrollBottom;\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent = offsetContent - physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top = top + physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top = top - physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return { indexes: idxs, physicalTop: top - this._scrollOffset };\n  },\n\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update: function (itemSet, movingUp) {\n    if ((itemSet && itemSet.length === 0) || this._physicalCount === 0) {\n      return;\n    }\n    this._manageFocus();\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        var idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n\n  _isClientFull: function () {\n    return (\n      this._scrollBottom != 0 &&\n      this._physicalBottom - 1 >= this._scrollBottom &&\n      this._physicalTop <= this._scrollPosition\n    );\n  },\n\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded: function (count) {\n    var nextPhysicalCount = this._clamp(\n      this._physicalCount + count,\n      DEFAULT_PHYSICAL_COUNT,\n      this._virtualCount - this._virtualStart\n    );\n    nextPhysicalCount = this._convertIndexToCompleteRow(nextPhysicalCount);\n    if (this.grid) {\n      var correction = nextPhysicalCount % this._itemsPerRow;\n      if (correction && nextPhysicalCount - correction <= this._physicalCount) {\n        nextPhysicalCount += this._itemsPerRow;\n      }\n      nextPhysicalCount -= correction;\n    }\n    var delta = nextPhysicalCount - this._physicalCount;\n    var nextIncrease = Math.round(this._physicalCount * 0.5);\n\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      var ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n      for (var i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount = this._physicalCount + delta;\n      // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n      if (\n        this._physicalStart > this._physicalEnd &&\n        this._isIndexRendered(this._focusedVirtualIndex) &&\n        this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd\n      ) {\n        this._physicalStart = this._physicalStart + delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    // The upper bounds is not fixed when dealing with a grid that doesn't\n    // fill it's last row with the exact number of items per row.\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce(\n        '_increasePoolIfNeeded',\n        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)),\n        idlePeriod\n      );\n    }\n  },\n\n  /**\n   * Renders the a new list.\n   */\n  _render: function () {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      var reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart = this._virtualStart + reusables.indexes.length;\n      this._physicalStart = this._physicalStart + reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n\n  _gridChanged: function (newGrid, oldGrid) {\n    if (typeof oldGrid === 'undefined') return;\n    this.notifyResize();\n    flush();\n    newGrid && this._updateGridMetrics();\n  },\n\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged: function (change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      this._physicalCount = this._physicalCount || 0;\n      this._physicalItems = this._physicalItems || [];\n      this._physicalSizes = this._physicalSizes || [];\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._removeFocusedItem();\n      this._debounce('_render', this._render, animationFrame);\n    } else if (change.path === 'items.splices') {\n      this._adjustVirtualIndex(change.value.indexSplices);\n      this._virtualCount = this.items ? this.items.length : 0;\n      // Only blur if at least one item is added or removed.\n      var itemAddedOrRemoved = change.value.indexSplices.some(function (splice) {\n        return splice.addedCount > 0 || splice.removed.length > 0;\n      });\n      if (itemAddedOrRemoved) {\n        // Only blur activeElement if it is a descendant of the list (#505,\n        // #507).\n        var activeElement = this._getActiveElement();\n        if (this.contains(activeElement)) {\n          activeElement.blur();\n        }\n      }\n      // Render only if the affected index is rendered.\n      var affectedIndexRendered = change.value.indexSplices.some(function (splice) {\n        return splice.index + splice.addedCount >= this._virtualStart && splice.index <= this._virtualEnd;\n      }, this);\n      if (!this._isClientFull() || affectedIndexRendered) {\n        this._debounce('_render', this._render, animationFrame);\n      }\n    } else if (change.path !== 'items.length') {\n      this._forwardItemPath(change.path, change.value);\n    }\n  },\n\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems: function (fn, itemSet) {\n    var pidx, vidx, rtn, i;\n\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx: function (pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics: function (itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n\n    var newPhysicalSize = 0;\n    var oldPhysicalSize = 0;\n    var prevAvgCount = this._physicalAverageCount;\n    var prevPhysicalAvg = this._physicalAverage;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._iterateItems(function (pidx, vidx) {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    if (this.grid) {\n      this._updateGridMetrics();\n      this._physicalSize = Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n    } else {\n      oldPhysicalSize =\n        this._itemsPerRow === 1\n          ? oldPhysicalSize\n          : Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n      this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n      this._itemsPerRow = 1;\n    }\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round(\n        (prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount\n      );\n    }\n  },\n\n  _updateGridMetrics: function () {\n    this._itemWidth = this._physicalCount > 0 ? this._physicalItems[0].getBoundingClientRect().width : 200;\n    this._rowHeight = this._physicalCount > 0 ? this._physicalItems[0].offsetHeight : 200;\n    this._itemsPerRow = this._itemWidth ? Math.floor(this._viewportWidth / this._itemWidth) : this._itemsPerRow;\n  },\n\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems: function () {\n    this._adjustScrollPosition();\n\n    var y = this._physicalTop;\n\n    if (this.grid) {\n      var totalItemWidth = this._itemsPerRow * this._itemWidth;\n      var rowOffset = (this._viewportWidth - totalItemWidth) / 2;\n\n      this._iterateItems(function (pidx, vidx) {\n        var modulus = vidx % this._itemsPerRow;\n        var x = Math.floor(modulus * this._itemWidth + rowOffset);\n        if (this._isRTL) {\n          x = x * -1;\n        }\n        this.translate3d(x + 'px', y + 'px', 0, this._physicalItems[pidx]);\n        if (this._shouldRenderNextRow(vidx)) {\n          y += this._rowHeight;\n        }\n      });\n    } else {\n      const order = [];\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      this._iterateItems(function (pidx, vidx) {\n        const item = this._physicalItems[pidx];\n        this.translate3d(0, y + 'px', 0, item);\n        y += this._physicalSizes[pidx];\n        const itemId = item.id;\n        if (itemId) {\n          order.push(itemId);\n        }\n      });\n      if (order.length) {\n        this.setAttribute('aria-owns', order.join(' '));\n      }\n    }\n  },\n\n  _getPhysicalSizeIncrement: function (pidx) {\n    if (!this.grid) {\n      return this._physicalSizes[pidx];\n    }\n    if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {\n      return 0;\n    }\n    return this._rowHeight;\n  },\n\n  /**\n   * Returns, based on the current index,\n   * whether or not the next index will need\n   * to be rendered on a new row.\n   *\n   * @param {number} vidx Virtual index\n   * @return {boolean}\n   */\n  _shouldRenderNextRow: function (vidx) {\n    return vidx % this._itemsPerRow === this._itemsPerRow - 1;\n  },\n\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition: function () {\n    var deltaHeight =\n      this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop = this._physicalTop - deltaHeight;\n      // This may be called outside of a scrollHandler, so use last cached position\n      var scrollTop = this._scrollPosition;\n      // juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition: function (pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize: function (forceUpdate) {\n    if (this.grid) {\n      this._estScrollHeight = this._virtualRowCount * this._rowHeight;\n    } else {\n      this._estScrollHeight =\n        this._physicalBottom +\n        Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n    }\n    forceUpdate = forceUpdate || this._scrollHeight === 0;\n    forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;\n    forceUpdate = forceUpdate || (this.grid && this.$.items.style.height < this._estScrollHeight);\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._viewportHeight) {\n      this.$.items.style.height = this._estScrollHeight + 'px';\n      this._scrollHeight = this._estScrollHeight;\n    }\n  },\n\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex: function (idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = this.grid ? idx - this._itemsPerRow * 2 : idx - 1;\n    }\n    this._manageFocus();\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;\n\n    var currentTopItem = this._physicalStart;\n    var currentVirtualItem = this._virtualStart;\n    var targetOffsetTop = 0;\n    var hiddenContentSize = this._hiddenContentSize;\n    // scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem++;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage: function () {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler: function () {\n    this._debounce(\n      '_render',\n      function () {\n        // clear cached visible index.\n        this._firstVisibleIndexVal = null;\n        this._lastVisibleIndexVal = null;\n        if (this._isVisible) {\n          this.updateViewportBoundaries();\n          // Reinstall the scroll event listener.\n          this.toggleScrollListener(true);\n          this._resetAverage();\n          this._render();\n        } else {\n          // Uninstall the scroll event listener.\n          this.toggleScrollListener(false);\n        }\n      },\n      animationFrame\n    );\n  },\n\n  /**\n   * Updates the size of a given list item.\n   *\n   * @method updateSizeForItem\n   * @param {Object} item The item instance.\n   */\n  updateSizeForItem: function (item) {\n    return this.updateSizeForIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Updates the size of the item at the given index in the items array.\n   *\n   * @method updateSizeForIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  updateSizeForIndex: function (index) {\n    if (!this._isIndexRendered(index)) {\n      return null;\n    }\n    this._updateMetrics([this._getPhysicalIndex(index)]);\n    this._positionItems();\n    return null;\n  },\n\n  /**\n   * Converts a random index to the index of the item that completes it's row.\n   * Allows for better order and fill computation when grid == true.\n   */\n  _convertIndexToCompleteRow: function (idx) {\n    // when grid == false _itemPerRow can be unset.\n    this._itemsPerRow = this._itemsPerRow || 1;\n    return this.grid ? Math.ceil(idx / this._itemsPerRow) * this._itemsPerRow : idx;\n  },\n\n  _isIndexRendered: function (idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n\n  _isIndexVisible: function (idx) {\n    return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;\n  },\n\n  _getPhysicalIndex: function (vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n\n  _clamp: function (v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n\n  _debounce: function (name, cb, asyncModule) {\n    this._debouncers = this._debouncers || {};\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  }\n};\n", "/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { animationFrame, timeOut } from './async.js';\nimport { isSafari } from './browser-utils.js';\nimport { Debouncer, flush } from './debounce.js';\nimport { ironList } from './iron-list-core.js';\n\n// iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\n\nexport class IronListAdapter {\n  constructor({ createElements, updateElement, scrollTarget, scrollContainer, elementsContainer, reorderElements }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements;\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500\n    };\n\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', (e) => this.__onWheel(e));\n\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => (this.__mouseDown = true));\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n\n  _manageFocus() {}\n\n  _removeFocusedItem() {}\n\n  get scrollOffset() {\n    return 0;\n  }\n\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n    index = this._clamp(index, 0, this.size - 1);\n\n    const visibleElementCount = this.__getVisibleElements().length;\n    let targetVirtualIndex = Math.floor((index / this.size) * this._virtualCount);\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this.size - this._virtualCount;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n    this._scrollHandler();\n  }\n\n  flush() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._resizeHandler();\n    flush();\n    this._scrollHandler();\n    this.__scrollReorderDebouncer && this.__scrollReorderDebouncer.flush();\n    this.__debouncerWheelAnimationFrame && this.__debouncerWheelAnimationFrame.flush();\n  }\n\n  update(startIndex = 0, endIndex = this.size - 1) {\n    this.__getVisibleElements().forEach((el) => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n      }\n    });\n  }\n\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary min height\n    if (el.style.minHeight) {\n      el.style.minHeight = '';\n    }\n\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n\n    if (el.offsetHeight === 0) {\n      // If the elements have 0 height after update (for example due to lazy rendering),\n      // it results in iron-list requesting to create an unlimited count of elements.\n      // Assign a temporary min height to elements that would otherwise end up having\n      // no height.\n      el.style.minHeight = '200px';\n    }\n  }\n\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find((el) => el.__virtualIndex === index);\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n\n  set size(size) {\n    if (size === this.size) {\n      return;\n    }\n\n    // Prevent element update while the scroll position is being restored\n    this.__preventElementUpdates = true;\n\n    // Record the scroll position before changing the size\n    let fvi; // first visible index\n    let fviOffsetBefore; // scroll offset of the first visible index\n    if (size > 0) {\n      fvi = this.adjustedFirstVisibleIndex;\n      fviOffsetBefore = this.__getIndexScrollOffset(fvi);\n    }\n\n    // Change the size\n    this.__size = size;\n\n    // Flush before invoking items change to avoid\n    // creating excess elements on the following flush()\n    flush();\n\n    this._itemsChanged({\n      path: 'items'\n    });\n    flush();\n\n    // Try to restore the scroll position if the new size is larger than 0\n    if (size > 0) {\n      fvi = Math.min(fvi, size - 1);\n      this.scrollToIndex(fvi);\n\n      const fviOffsetAfter = this.__getIndexScrollOffset(fvi);\n      if (fviOffsetBefore !== undefined && fviOffsetAfter !== undefined) {\n        this._scrollTop += fviOffsetBefore - fviOffsetAfter;\n      }\n    }\n\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n\n    this.__preventElementUpdates = false;\n    // Schedule and flush a resize handler\n    this._resizeHandler();\n    flush();\n  }\n\n  get size() {\n    return this.__size;\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n\n  /** @private */\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n\n  /** @private */\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT)\n    };\n  }\n\n  /** @private */\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n\n  /** @private */\n  get $() {\n    return {\n      items: this.scrollContainer\n    };\n  }\n\n  /** @private */\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    this.grid && this._updateGridMetrics();\n  }\n\n  /** @private */\n  setAttribute() {}\n\n  /** @private */\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach((el) => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n      this.__resizeObserver.observe(el);\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n\n  /** @private */\n  _assignModels(itemSet) {\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n        this.__updateElement(el, el.__virtualIndex);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n  }\n\n  /** @private */\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => (this.__clientFull = true));\n    return this.__clientFull || super._isClientFull();\n  }\n\n  /** @private */\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n\n  /** @private */\n  toggleScrollListener() {}\n\n  _scrollHandler() {\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n\n    super._scrollHandler();\n\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = Debouncer.debounce(\n        this.__scrollReorderDebouncer,\n        timeOut.after(this.timeouts.SCROLL_REORDER),\n        () => this.__reorderElements()\n      );\n    }\n\n    this.__previousScrollTop = this._scrollTop;\n  }\n\n  /** @private */\n  __onWheel(e) {\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n      return;\n    }\n\n    let deltaY = e.deltaY;\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n      // Scrolling by \"lines of text\" instead of pixels\n      deltaY *= this._scrollLineHeight;\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n      // Scrolling by \"pages\" instead of pixels\n      deltaY *= this._scrollPageHeight;\n    }\n\n    this._deltaYAcc = this._deltaYAcc || 0;\n\n    if (this._wheelAnimationFrame) {\n      // Accumulate wheel delta while a frame is being processed\n      this._deltaYAcc += deltaY;\n      e.preventDefault();\n      return;\n    }\n\n    deltaY += this._deltaYAcc;\n    this._deltaYAcc = 0;\n\n    this._wheelAnimationFrame = true;\n    this.__debouncerWheelAnimationFrame = Debouncer.debounce(\n      this.__debouncerWheelAnimationFrame,\n      animationFrame,\n      () => (this._wheelAnimationFrame = false)\n    );\n\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n      e.preventDefault();\n      this.scrollTarget.scrollTop += deltaY;\n      this.scrollTarget.scrollLeft += e.deltaX;\n\n      this._hasResidualMomentum = true;\n\n      this._ignoreNewWheel = true;\n      this._debouncerIgnoreNewWheel = Debouncer.debounce(\n        this._debouncerIgnoreNewWheel,\n        timeOut.after(this.timeouts.IGNORE_WHEEL),\n        () => (this._ignoreNewWheel = false)\n      );\n    } else if ((this._hasResidualMomentum && momentum <= this._previousMomentum) || this._ignoreNewWheel) {\n      e.preventDefault();\n    } else if (momentum > this._previousMomentum) {\n      this._hasResidualMomentum = false;\n    }\n    this._previousMomentum = momentum;\n  }\n\n  /**\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\n   *\n   * @private\n   */\n  _hasScrolledAncestor(el, deltaX, deltaY) {\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n      return false;\n    } else if (\n      this._canScroll(el, deltaX, deltaY) &&\n      ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1\n    ) {\n      return true;\n    } else if (el !== this && el.parentElement) {\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n    }\n  }\n\n  _canScroll(el, deltaX, deltaY) {\n    return (\n      (deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight) ||\n      (deltaY < 0 && el.scrollTop > 0) ||\n      (deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth) ||\n      (deltaX < 0 && el.scrollLeft > 0)\n    );\n  }\n\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter((element) => !element.hidden);\n  }\n\n  /** @private */\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n    this.__pendingReorder = false;\n\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n    // Which row to use as a target?\n    const visibleElements = this.__getVisibleElements();\n\n    const elementWithFocus = visibleElements.find(\n      (element) =>\n        element.contains(this.elementsContainer.getRootNode().activeElement) ||\n        element.contains(this.scrollTarget.getRootNode().activeElement)\n    );\n    const targetElement = elementWithFocus || visibleElements[0];\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    }\n\n    // Where the target row should be?\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n    // Reodrer the DOM elements to keep the target row at the target physical index\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    }\n\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n    if (isSafari) {\n      const { transform } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => (this.scrollTarget.style.transform = transform));\n    }\n  }\n\n  /** @private */\n  _adjustVirtualIndexOffset(delta) {\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n      return;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n      const offset = scale * this.size;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100;\n\n      // Near start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      }\n\n      // Near end\n      const maxOffset = this.size - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n}\n\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);\n", "import { IronListAdapter } from './virtualizer-iron-list-adapter.js';\n\nexport class Virtualizer {\n  /**\n   * @typedef {Object} VirtualizerConfig\n   * @property {Function} createElements Function that returns the given number of new elements\n   * @property {Function} updateElement Function that updates the element at a specific index\n   * @property {HTMLElement} scrollTarget Reference to the scrolling element\n   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget\n   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer\n   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM\n   * @param {VirtualizerConfig} config Configuration for the virtualizer\n   */\n  constructor(config) {\n    this.__adapter = new IronListAdapter(config);\n  }\n\n  /**\n   * The size of the virtualizer\n   * @param {number} size The size of the virtualizer\n   */\n  set size(size) {\n    this.__adapter.size = size;\n  }\n\n  /**\n   * The size of the virtualizer\n   * @return {number | undefined} The size of the virtualizer\n   */\n  get size() {\n    return this.__adapter.size;\n  }\n\n  /**\n   * Scroll to a specific index in the virtual list\n   *\n   * @method scrollToIndex\n   * @param {number} index The index of the item\n   */\n  scrollToIndex(index) {\n    this.__adapter.scrollToIndex(index);\n  }\n\n  /**\n   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM\n   *\n   * @method update\n   * @param {number | undefined} startIndex The start index of the range\n   * @param {number | undefined} endIndex The end index of the range\n   */\n  update(startIndex = 0, endIndex = this.size - 1) {\n    this.__adapter.update(startIndex, endIndex);\n  }\n\n  /**\n   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state\n   *\n   * @method update\n   * @param {number | undefined} startIndex The start index of the range\n   * @param {number | undefined} endIndex The end index of the range\n   */\n  flush() {\n    this.__adapter.flush();\n  }\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get firstVisibleIndex() {\n    return this.__adapter.adjustedFirstVisibleIndex;\n  }\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get lastVisibleIndex() {\n    return this.__adapter.adjustedLastVisibleIndex;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
